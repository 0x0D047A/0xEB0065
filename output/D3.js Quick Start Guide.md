# D3.js Quick Start Guide

Chapter 1. Getting Started with D3.js
-------------------------------------

 The era of big data is upon us! Advances in hardware have made it possible for computers to store, analyze, and transmit massive amounts of information in a way that was previously impossible. Data science has become one of the most in-demand fields in the United States, and companies are constantly coming up with new techniques to analyze customer information; it seems as if every day there are new ways to visualize all this data. **D3** has become the most popular library used to create dynamic, interactive, data-driven visualizations on the web. Unlike many technologies previously used in data vizualization , D3 leverages the power of combining SVG images with web browsers and JavaScript. In this chapter, we'll discuss the following topics:

*   What is SVG?
*   What makes D3 so special?
*   This book's approach to learning


What is SVG?
------------

* * *

One of the best ways to present your data is via an interactive graphic on the web. The advantage of this approach is that its interactivity allows creators to pack more information into a single visualization, while the ubiquity of the web allows anyone to instantly access it. Gone are the days of PowerPoint presentations, or, worse still, printing static images on to paper as handouts. There are many ways to create a web-based interactive data visualization, but none of them is more popular than the JavaScript library called **D3.js**.

To understand why `D3.js` works so well, it's important to understand what SVG is and how it relates to D3. **SVG** stands for **Scalable Vector Graphics**, and it's a way to display shapes using mathematical directions/commands. Traditionally, the information for an image is stored in a grid, also called a raster. Each square (called a pixel) of the image has a specific color:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzL2E1NTQ3MjIyLWZkNzUtNDJmMi1hMTlhLTNlNjZjOTQ4MTUyMw==.png)

But with SVG, a set of succinct drawing directions is stored. For example, the drawing command for a circle is as follows:

Copy

This code produces a much smaller file size, and because it's a set of drawing directions, the image can be enlarged without any pixelation. A raster image becomes blurry and pixelated as it's enlarged. The advantage of raster graphics over vector graphics is that they're great for storing complex images such as photographs. With a photograph, where each pixel probably has a different color, it's better to use a raster image. Imagine writing SVG drawing commands for a photograph: you would end up creating a new element for each pixel, and the file size would be too large.

Once an SVG drawing command is written, a program needs to interpret the command and display the image. Up until recently, only designated drawing applications such as Adobe Illustrator could view and manipulate these images. But by 2011 all major modern browsers supported SVG tags, allowing for developers to embed SVG directly on a web page. Since the SVG image was directly embedded in the code of a web page, JavaScript, which normally is used for manipulating HTML, could be used to manipulate the shape, size, and colors of the image in response to user events. To make the circle in the SVG example you have just seen grow to twice its original size, all that JavaScript had to do was change the rattribute:

Copy

This was the massive breakthrough that allowed complex interactive data visualizations to be hosted on the web.


What makes D3 so special?
-------------------------

* * *

D3.js came in at this point because writing the code to make complex data-driven documents (how D3 got its name) that linked SVG images with the big data that had become available on the internet was a difficult task. It rose to prominence during the Obama/Romney presidential debates as the New York times published a series of amazing visualizations. Check out some examples here:

*   [https://archive.nytimes.com/www.nytimes.com/interactive/2012/11/07/us/politics/obamas-diverse-base-of-support.html](https://archive.nytimes.com/www.nytimes.com/interactive/2012/11/07/us/politics/obamas-diverse-base-of-support.html)
*   [http://archive.nytimes.com/www.nytimes.com/interactive/2012/11/02/us/politics/paths-to-the-white-house.html](http://archive.nytimes.com/www.nytimes.com/interactive/2012/11/02/us/politics/paths-to-the-white-house.html)
*   [https://archive.nytimes.com/www.nytimes.com/interactive/2012/10/15/us/politics/swing-history.html](https://archive.nytimes.com/www.nytimes.com/interactive/2012/10/15/us/politics/swing-history.html)
*   [https://www.nytimes.com/elections/2012/electoral-map.html](https://www.nytimes.com/elections/2012/electoral-map.html)
*   [https://archive.nytimes.com/www.nytimes.com/interactive/2012/09/06/us/politics/convention-word-counts.html](https://archive.nytimes.com/www.nytimes.com/interactive/2012/09/06/us/politics/convention-word-counts.html)
*   [https://archive.nytimes.com/www.nytimes.com/interactive/2012/03/07/us/politics/how-candidates-fared-with-different-demographic-groups.html](https://archive.nytimes.com/www.nytimes.com/interactive/2012/03/07/us/politics/how-candidates-fared-with-different-demographic-groups.html)

D3 simplifies some of the most common, as well as some of the most, complex tasks that a developer can run into when creating browser-based visualizations. At its core, D3 easily maps SVG image properties to data values. As the data values change, due to user interactions, so do the images.


This book's approach to learning
--------------------------------

* * *

D3 is a massive library, full of millions of options, but its core concepts are easy to learn. You do not need to know every detail of the library to become a functional D3 developer. Instead, this book attempts to teach the most fundamental aspects of D3 so that the reader can get job-ready quickly. It does so by stepping the user through a series of the most common graphs that a developer will be asked to make: a scatter plot, a bar graph, a pie chart, a force-directed graph, and a map. The goal is not only to teach the basics but also to give the reader a final set of builds that are fun to work, toward as well as useful to draw from as their career continues.

Please note, the code demonstrated here was created to be easy to understand from an educational standpoint. It is not meant to be code that is ready for production. Nor does it employ ES6 or ES7 syntax. Often, demonstrating a concept in code that is production-ready or written in ES6/ES7 can hinder the educational experience. It is assumed that the reader is comfortable enough with the core concepts of programming that they can refine the code on their own, once they are comfortable with the fundamentals of D3.


A preview of each build
-----------------------

* * *

Each chapter focuses on a specific build. The completed build code for each chapter can be found at: [https://github.com/PacktPublishing/D3.js-Quick-Start-Guide](https://github.com/PacktPublishing/D3.js-Quick-Start-Guide).

### Using SVG to create images using code

In this chapter, we learn how to render shapes in the browser, using SVG. We'll cover shapes such as these:

*   Circles:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzL2M0NzNiOTZjLTdkNzktNGIxYy05NGUyLWJmZTQwMTJkOWVhOA==.png)

*   Lines:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzLzU5M2JkOGQ2LWMwZjMtNDM4Ny1iYWRiLTBlMTYzMjgzN2ZlZg==.png)

*   Rectangles:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzLzU1NTc2NDc0LTJjYTctNGQ2OS1hMDdkLWM5NzljNjBkNTVjNA==.png)

*   Ellipses:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzLzJjN2Q1NDUxLTlhYTUtNGM3NC04NmUyLTU4MTgxMjNlY2QzYg==.png)

*   Polygons:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzLzExMTZiMWJmLTMwYjctNDUyMi05YjkyLTU3NzkzZTVmMGJlMA==.png)

*   Polylines:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzL2I4NTE2ODE1LTI3NmMtNDliOC1iNzgxLTRjOTkyZDViMGYyZQ==.png)

*   Cubic Bezier Curves:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzL2RjNDg3YTYzLWU2NTktNGJjNy05YzNkLWFjNTlhZTU1NDMxZg==.png)

The completed code for this section can be found here: [https://github.com/PacktPublishing/D3.js-Quick-Start-Guide/tree/master/Chapter02](https://github.com/PacktPublishing/D3.js-Quick-Start-Guide/tree/master/Chapter02).

### Building an interactive scatter plot

In this chapter, you'll learn how to plot points on a graph to create a scatter plot.  It will look a bit like this:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzL2YyMGI4MzNjLTM2NDItNDcxOS1hMjI5LTg2Nzg2N2ZhMzQzMw==.png)

The completed code for this section can be found here: [https://github.com/PacktPublishing/D3.js-Quick-Start-Guide/tree/master/Chapter03](https://github.com/PacktPublishing/D3.js-Quick-Start-Guide/tree/master/Chapter03).

### Making a basic scatter plot interactive

This chapter builds on the previous one, adding interactive functionality that allows you to do the following:

*   Create new points:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzL2Q2MTk5N2U3LTU5NjAtNGUwMi1hN2MyLTA1MDIzOGY4NmRjOA==.png)

*   Remove points:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzL2M0NzRlOTdiLWRlMDktNDQ1ZC05OTYwLTRjNTUxZTViMmFiYQ==.png)

*   Update points:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzL2U4MTJmYjFjLWQ4OWEtNDhiOS05MzRmLTQyZWJhOTgwYTI4OA==.png)

*   Zoom and pan:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzLzgwNjZkZTdmLWRmNTgtNGJiMi1iN2RmLWU5MTI2ODI3N2I0ZQ==.png)

The completed code for this section can be found here: [https://github.com/PacktPublishing/D3.js-Quick-Start-Guide/tree/master/Chapter04](https://github.com/PacktPublishing/D3.js-Quick-Start-Guide/tree/master/Chapter04).

### Creating a bar graph using a data file

In this chapter, we'll learn how to use AJAX to make an asynchronous call, after the page has loaded, to retrieve some JSON data and render it as a bar graph. It should look as follows:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzLzQ0ZjY0ZTJhLWJkYzctNDU1OC05YmE3LTlhN2IwYjJhNTgyOQ==.png)

The completed code for this section can be found here:[https://github.com/PacktPublishing/D3.js-Quick-Start-Guide/tree/master/Chapter05](https://github.com/PacktPublishing/D3.js-Quick-Start-Guide/tree/master/Chapter05).

### Animating SVG elements to create an interactive pie chart

In this chapter, we'll learn how to make a pie chart:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzLzgxZjUzNjdkLWY2ZmUtNGRlYy05MzU2LTA3YjFkOTBlMDY5Nw==.png)

Then we'll turn it into a donut chart:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzL2ZkNjIxMDM1LWMwM2MtNDA5OC1hYzA0LWFiZDk4ODhkM2I0ZA==.png)

And then we'll create functionality so that the user can remove a section of the chart and it will close the gap with a smooth transition:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzL2I0N2JjMDQzLWVkYzUtNGU0ZS05ZmI2LThkODkyMjk1MmMwMA==.png)

The completed code for this section can be found here:[https://github.com/PacktPublishing/D3.js-Quick-Start-Guide/tree/master/Chapter06](https://github.com/PacktPublishing/D3.js-Quick-Start-Guide/tree/master/Chapter06).

### Using physics to create a force-directed graph

In this chapter, we'll graph relationships between people with a force-directed graph. It will look as follows:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzLzZmODhhNjA5LTQzNWUtNDFmOS04OTFhLTA2OGQxYTBhMTVkZg==.png)

The completed code for this section can be found here:[https://github.com/PacktPublishing/D3.js-Quick-Start-Guide/tree/master/Chapter07](https://github.com/PacktPublishing/D3.js-Quick-Start-Guide/tree/master/Chapter07).

### Mapping

In [Chapter 8](/book/application_development/9781789342383/8), _Mapping_, we'll learn how to use GeoJSON data to create a map of the world. It will look as follows:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzLzAyYmE4NjkzLTQxZjItNDE2NC1iZjRmLTgyYjU0MWU4MWEzYw==.png)

The completed code for this section can be found here:[https://github.com/PacktPublishing/D3.js-Quick-Start-Guide/tree/master/Chapter08](https://github.com/PacktPublishing/D3.js-Quick-Start-Guide/tree/master/Chapter08).


Setting up
----------

* * *

For this book, you really only need to download and install the following:

*   Chrome: [https://www.google.com/chrome/](https://www.google.com/chrome/).
    
    *   A web browser so that we can view our visualizations.
    
*   Node: [https://nodejs.org/en/](https://nodejs.org/en/).
    
    *   This allows us to run javascript from the terminal. In [Chapter 4](/book/application_development/9781789342383/4), _Making a Basic Scatter Plot Interactive_,we will use it so that we can make AJAX calls.
    
*   A code editor. I'd suggest Atom if you're new to coding:[ https://atom.io/](https://atom.io/).


Summary
-------

* * *

In this chapter, you've received a high-level overview of what makes D3 so interesting. We examined what an SVG element is and set up our machine so that it is ready to create D3 code. We also took a look at this book's approach to learning and how it applies to the applications that we'll build. In [Chapter 2](/book/application_development/9781789342383/2), _Using SVG to Create Images Using Code_, we'll dive into creating SVG elements.


Chapter 2. Using SVG to Create Images Using Code
------------------------------------------------

SVG elements are a way to create images within a web page and are the foundation of D3 and how it works. They use code to create shapes, rather than defining each pixel of an image. This chapter covers how to create various SVG elements within a web page. In it, we will cover the following topics:

*   Base tags
*   Basic elements
*   Positioning
*   Styling
*   Important SVG elements

The complete code for this section can be found here: [https://github.com/PacktPublishing/D3.js-Quick-Start-Guide/tree/master/Chapter02](https://github.com/PacktPublishing/D3.js-Quick-Start-Guide/tree/master/Chapter02).


Base tag
--------

* * *

When viewing SVG graphics in a browser, it's important to embed an `<svg>` tag inside an HTML page. Let's create an `index.html` file and add the following to it:

Copy

Now start a web browser and open that file (usually, **`File`** | **`Open File`**). For this book, it is recommended that the reader use Google Chrome, but in development and production, any browser will do.  If we inspect our HTML in the **`Elements`** tab of Chrome's Dev Tools (**`View`** | **`Developer`** | **`Developer Tools`**), we'll see the following:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzL2E4ZWRkZGY5LWViMDEtNDZlZi04NmUzLWJkZWZhMzVkMTcyNA==.png)


Basic elements
--------------

* * *

We can draw elements in our `<svg>` element by adding a variety of predefined tags as child elements of the `<svg>`. This is just as we did in HTML, where we add `<div>`, `<a>`, and `<img>` tags inside the `<body>` tag. There are many tags, such as `<circle>`, `<rect>`, and `<line>`, that we'll explore in a bit. Here's just one example:

Copy

Note that we can't see the circle because it doesn't have a radius, as shown in this screenshot:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzLzU2NzkxMDhlLTVjY2EtNGI1OC05NTlkLTUzYWIxZmI3ODk0OQ==.png)

We'll talk more about this later, but, for now, if we want to see the circle, we can add a special attribute that all `<circle>` elements take:

Copy

This tells the browser to give the circle a radius of `50` px, which is shown in the following screenshot:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzL2Y1MDIwZTg3LTU3MWQtNGU5Ny05Y2EwLWRmODUxOTZjZmYzYQ==.png)

At the moment, though, we only see the lower–right quarter of the circle. This is because the center of the circle is being drawn at the very upper–left corner of the `<svg>`, and the rest of it is being clipped outside the `<svg>`. We can change this by changing the position of the circle, which we'll do next.


Positioning an element
----------------------

* * *

The `<svg>` tag is an inline element, such as an image (as opposed to a block element such as a `<div>`).  Elements within the `<svg>` are positioned similar to Photoshop, with a set of coordinates that follow the form `(x,y)`.  An example of this could be `(10,15)`, which translates to `x=10` and `y=15`. This is different than HTML, where elements are laid out relative to one another. Here are some important things to keep in mind:

*   The point `(0,0)` is the upper–left corner of the `<svg>` element.
*   As _y_ values increase, the point moves vertically down the `<svg>` element.
*   Don't confuse this with a typical coordinate system that has `(0,0)` at the lower–left corner with a point moving up, as _y_ increases in value. This diagram shows the difference between a traditional coordinate system and an SVG coordinate system:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzL2FmNTM0ODdiLThjMGUtNGI2ZC04ODM3LWYwMjc2MzFiODdiNg==.png)

We can use negative _x_/_y_ values:

*   _\-x_: moves left
*   _\-y_ :moves up

Let's adjust the position of our circle in our previous section by adjusting `cx` and `cy` values (the _x_ and _y_ values for the center of the element):

Copy

Now we see the full circle:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzLzQzZWQ1MGE5LTI1Y2ItNDliZC1hMzhlLWZhOWE0OWQwMTEwNw==.png)


Styling an element
------------------

* * *

The appearance of any tag inside an `<svg>` can be styled with the following attributes (the following are the attributes with example values):

*   `fill=red` or `fill=#ff0000` will alter the color of the shape.
*   `stroke=red` or `stroke=#ff0000` will alter stroke color. Stroke is a line that surrounds each element.
*   `stroke-width=4` will adjust the width of the stroke.
*   `fill-opacity=0.5` will adjust the transparency of the fill color.
*   `stroke-opacity=0.5` will adjust the transparency of the stroke color.
*   `transform = "translate(2,3)"` will translate the element by the given _x_, _y_ values.
*   `transform = "scale(2.1)"` will scale the size of the element by the given proportion (for example, `2.1` times as big).
*   `transform = "rotate(45)"` will rotate the element by the given number of degrees.

Let's style the circle we positioned previously:

Copy

Now we get this:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzLzYyMjlhMzgyLTJjMmItNDc5ZC1hMmYzLTYyY2RlNGMzZjE4ZQ==.png)

Note that the stroke in the preceding screenshot is getting clipped. That's because the stroke is created outside the element. If we want to see the full stroke, we can resize the circle:

Copy

Now we get the following output:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzLzFmMjhmNjhkLTQ0MzctNGZmMy05MWU1LTQ0N2UxNWVmNGU3Ng==.png)

Styling can also be done with CSS. The following steps will tell you how to style your `<svg>` element with CSS:

1.  Create an external `app.css` file in the same folder as your `index.html` file with the following contents:

Copy

          circle {
             fill:red;
             stroke:blue;
             stroke-width:3;
             fill-opacity:0.5;
             stroke-opacity:0.1;
             transform:rotate(45deg) scale(0.4) translate(155px, 
    1px);
             r:50px;
         }

2.  Link the file in the `<head>` tag of `index.html`:

Copy

3.  Lastly, remove our previous inline styling that we had on our `<circle>` tag:

Copy

Now we get this result:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzLzUwZGNkZTQ0LTA0OTMtNDEwZi04Mjc2LWRiZmRmYzg2ZjE0Yg==.png)

Note that I've hovered over the element in the dev tools to show that the element has been rotated 45 degrees. That's what the blue box is.


Important SVG elements
----------------------

* * *

To demonstrate each element, we'll use the following code as a starting point and then add each element inside the `<svg>` tag:

Copy

Let's now move on to each element. Note that you can write each tag in the form `<element></element>`, as we did with `<circle></circle>` previously, or the self-closing form, `<element/>`, which you will see next with `<circle/>`.

### Circle

Circles have the following attributes:

*   `r`: radius
*   `cx`: _x_ position
*   `cy`:_ y_ position

Copy

The output for the previous code will be as follows:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzLzUxZjU5M2U3LWI1NWEtNDU1Yy1iOTdkLWRjNzU2Y2Y1ZGRhMw==.png)

### Line

Lines have the following attributes:

*   `x1`: starting _x_ position
*   `y1`: starting _y_ position
*   `x2`: ending _x_ position
*   `y2`: ending _y_ position

Here are two examples:

Copy

The following output will be displayed:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzLzZkZTM0ZTM0LTBlOTgtNDcxNC05NDAwLTdiZWQ5YmY1ZTc0NA==.png)

### Rectangle

Rectangles have the following attributes:

*   `x`: _x_ position of upper–left
*   `y`: _y_ position of top left
*   `width`: width
*   `height`: height

Here's an example:

Copy

Here's what this code produces:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzLzkyYzE2YTIyLTI3NjgtNDg0Zi05MjUyLTFhOTcwOGJlZTc3Nw==.png)

### Ellipse

An ellipse has the following attributes:

*   `cx`: _x_ position
*   `cy`: _y_ position
*   `rx`: _x_ radius
*   `ry`: _y_ radius

The attributes will be as follows:

Copy

The output can be seen as follows:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzLzEwYjVlNzk2LTAyYjMtNDI1Yy1hYzZjLWJhY2RiMTdlMmI4Zg==.png)

### Polygon

Polygons have the following attributes:

*   `points`, which is a set of coordinate pairs
*   Each pair is of the form `x,y`

The attributes will be as follows:

Copy

The output can be seen as follows:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzL2UwNDM2NDM2LTI5ZmEtNDg2Mi1iNjhhLWU0M2UyZWFjNGI2MQ==.png)

### Polyline

**Polyline** is a series of connected lines. It can have a fill, as a polygon does, but it won't automatically rejoin itself:

Copy

The output will be as follows:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzLzhiODllOTI1LTc3OWMtNGIyMS05MWMxLTEwNjgxMDUzY2MxMg==.png)

### Text

The content of the tag is the text to be displayed. It has the following attributes:

*   `x`, the _x_ position of upper–left corner of the element
*   `y`, the _y_ position of upper-left corner of the element

The attributes can be used as follows:

Copy

    I love SVG!

You can use `font-family` and `font-size` CSS styling on this element.

### Group

This element has no special attributes, so we'll use transform to position it. You can put multiple elements inside it and all of its positioning will apply to its children. It's good for moving many elements together as one:

Copy

### Bezier curves

What if we want to draw complex organic shapes? To do this, we'll need to use paths. First, though, to understand paths, you have to understand **Bezier curves**.

#### Cubic Bezier curves

There are two types of Bezier curves:

*   Bezier curves ([http://blogs.sitepointstatic.com/examples/tech/svg-curves/cubic-curve.html](http://blogs.sitepointstatic.com/examples/tech/svg-curves/cubic-curve.html))
*   Quadratic Bezier curves ([http://math.hws.edu/eck/cs424/notes2013/canvas/bezier.html](http://math.hws.edu/eck/cs424/notes2013/canvas/bezier.html))

Each curve is made up of four points:

*   Start point
*   End point
*   Starting control point
*   Ending control point

The start/end points are where the curve starts and ends. The control points define the shape of the curve. It's easiest to conceptualize it with the following diagram:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzLzJiMWI3NjM4LTE2NzgtNDEzYy05ZDIwLTNlOTJhOTU0ZTMxOQ==.png)

As we manipulate the control points, we can see how the shape of the curve is affected:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzL2Q5N2NkMWUyLWEwZmUtNDg1NS1iYmVmLTZhYzA1ZDg3ZWRmNQ==.png)

You can even join multiple Bezier curves together, as shown in this diagram:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzL2YzYzliOWQwLTIxZDUtNDdkNS05NTZkLWU0MjQyYTYyNTAyNg==.png)

#### Smooth cubic Bezier curves

Smooth cubic Bezier curves are just a way to simplify some cubic Bezier curves when they're joined together. Take a look at the two control points in the red square shown in this diagram:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzLzYzMWRjMzE5LTU1MmMtNDYyMS1iMGJiLTYyYjc2MjJjYjlmOQ==.png)

The point in the lower–left corner of the square is the end control point of the first curve. The point in the upper-right corner of the square is start control point of the second curve.

Note that the two points are reflections of each other around the central black dot, which is the end point of the first curve and the start point of the second curve. The two points are exactly 180 degrees from each other, and they have the same distance from that central point.

In scenarios such as this, where the start control point of one curve is a reflection of the end control point of the previous curve, we can skip stating the start control point of the second curve. Instead, we let the browser calculate it, based on the end control point of the first curve:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzL2NmMjgyN2ZlLTBiMzUtNDRlYy1hYzU5LTNjYmU5MWI4ZDI1Nw==.png)

We can also omit the start point, since the browser knows it will be the same as the end point of the previous curve. In summary, to define that second curve, we only need two points:

*   The end point
*   The end control point

#### Quadratic Bezier curve

Another situation where we can simplify defining a Bezier curve is where the start control point and end control point are the same:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzL2YzZjFiY2QzLTY0ZWMtNDEzNy1hOWJkLTEyOTMzMzE1OGQ3OQ==.png)

Here, we can define the curve with just three points:

*   The start point
*   The end point
*   One single control point that acts as both a start control point and an end control point

#### Smooth quadratic Bezier curve

The final situation where we can simplify defining a Bezier curve is where we have a quadratic Bezier curve (one single control point) that is a reflection of the end control point of a previous curve:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzLzRlNGVjYTkyLTE0MGUtNDA4OC1hZGE5LWNiOGZjZGRkN2Y4NQ==.png)

In this situation, the browser knows the start point of the curve (the end point of the previous curve), and it can calculate the single control point needed (since it is a quadratic Bezier curve) based on the end control point of the previous curve. This is a smooth quadratic Bezier curve, and you only need one point to define it:

*   The end point

### Drawing a path

Now that we understand Bezier curves, we can use them in our SVGs with `<path>` elements.

Documentation can be found here: [https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths](https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths).

These tags take a `d` attribute, which stands for a set of drawing commands. The value of this attribute is any combination of the following:

*   M = moveto: move the drawing point to the given coordinates
    
    *   M _x y_
    
*   L = lineto: draw a line from the previous point in the d command to the point given
    
    *   L _x y_
    
*   C = curveto: draw a curve from the previous point in the `d` command to the point given with the given control points
    
    *   C _x_1 _y_1, _x_2 _y_2, _x y_
    *   The first pair is first control point
    *   The second pair is second control point
    *   The last pair is final ending point of curve
    
*   S = smooth curveto:
    
    *   S _x_2 _y_2, _x y_
    *   Follows another curve
    *   Uses a reflection of _x_2 _y_2 of the previous S or C command for _x_1 _y_1
    
*   Q = quadratic Bezier curve:
    
    *   Q _x_1 _y_1, _x y_
    *   Uses one control point for start and end controls (_x_1, _y_1)
    
*   T = smooth quadratic Bezier curveto:
    
    *   T _x y_
    *   Follows another curve
    *   Uses a reflection of the previous quadratic curve's control point as its control point
    
*   Z = closepath: draws a line from the previous point in the `d` command to the first point in the `d` command

### Note

Note that all of these commands can also be expressed with lowercase letters. If capital letters are used, this means absolutely positioned (relative to the upper–left corner of the SVG element); lowercase letters mean that all the points are expressed relative to the previous point in the `d` command.

Let's use lines to draw a triangle:

Copy

The following output will be displayed:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzLzQzYTAxYmRmLTYxZjUtNGQyZi05ZTExLTU5MDIxM2U1NTE0Yw==.png)

Next, we'll draw a Bezier curve:

Copy

The following output will be displayed:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzL2UwN2RmNTNhLTZhNjQtNDY5Mi1hNDliLWQ0NWQzM2MxYzdmMw==.png)

Here's a quadratic Bezier curve:

Copy

The following output will be displayed:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzLzM0MzQ4YTAwLTBiYzYtNGNhMC04ZTgwLTkyZWRiYjUyNzk4Mg==.png)

#### Arcs

An **arc** is a command that you can add to a path that will draw part of an ellipse. To do this, we begin with only two points:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzLzUwYmM1NjA1LTEyYWYtNGE3Yi04OTcyLWMwN2YyYTUyY2QzOQ==.png)

For any two points, there are only two ellipses with the same width/height and rotation that contain both points. In the previous diagram, try to imagine moving the ellipses around without rotating or scaling them. As soon as you do, they lose contact with at least one of the two given points. One point might be on the ellipse, but the other won't be.

We can use this information to draw any of the four colored arcs shown in the previous diagram.

Make the following code part of the `d` attribute's value on a `<path>` element:

Copy

    A rx ry x-axis-rotation large-arc-flag sweep-flag x y

Let's look at the various properties of an arc:

*   `A`: creates an arc draw command
*   `rx`: the _x_ radius of both ellipses (in px)
*   `ry`: the _y_ radius of both ellipses (in px)
*   `x-axis-rotation`: rotates both ellipses a certain number of degrees
*   `large-arc-flag`: indicates whether to travel along the arc that contains more than 180 degrees (1 to do so, 0 to not do so)

*   `sweep-flag`: indicates whether to move along the arc that goes clockwise (1 to do so, 0 to not do so)
*   `x`: destination _x_ value (in px)
*   `y`: destination _y_ value (in px)

`large-arc-flag` determines whether to make an arc that is greater than 180 degrees. Here's an example without it (note, the red shows the arc drawn, while the green arcs are other possible arcs that could be drawn using a combination of `large-arc-flag` and `sweep-flag`):

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzLzU5YThmNTlkLTVjMDEtNDYyNS1iNDE3LTFiMDgxNmExZGIxNw==.png)

Note, it chooses one of the two smaller arcs. Here's an example with the `large-arc-flag` set:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzLzljNmQ4ZTg4LTQ4YmEtNDRlMi05NDYzLTgwZTg3OTQxYzJjZg==.png)

Note, it chooses one of the two larger arcs.

In the previous example, for both situations where the `large-arc-flag` was set or not set, there was one other arc that could have been taken. To determine which of those two arcs to take, we use the `sweep-flag`, which determines whether to travel clockwise from the start point to the end point. Here's an example with the` large-arc-flag` set, but without the `sweep-flag` set:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzLzg0ODg1YmQwLWFlN2EtNDZjZi1hZTA5LTZkZjAyYjcwM2I5ZA==.png)

Note that we move in a counterclockwise motion from start to end (left to right). If we set the `sweep-flag`, we travel in a clockwise motion:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzLzkzNWQ2NjNiLTMyNjItNGNmNi05ZjljLTZjOWI0MTFmYjU5ZA==.png)

Here are all the possible combinations for `sweep-flag` and `large-arc-flag`:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzL2ZhNWUwMjQ4LWNmN2MtNDBjNi1iYzBkLTUzODgyM2MyZDU5NA==.png)

Here's an example code for a `path` that uses an arc in its `d` attribute:

Copy

Here's what it looks like:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzLzUwYTIxZmZkLTBkYzgtNDhiOC1iNTNlLTMzYWNhYTM1YjFkOA==.png)

Play with the different kinds of arc values here: [http://codepen.io/lingtalfi/pen/yaLWJG](http://codepen.io/lingtalfi/pen/yaLWJG).

### Documentation

If needed, you can find all the documentation for SVG elements here: [https://developer.mozilla.org/en-US/docs/Web/SVG/Element](https://developer.mozilla.org/en-US/docs/Web/SVG/Element).


Summary
-------

* * *

In this chapter, we covered the basics of SVG (base tags, basic elements, positioning, and styling). We also looked at Bezier curves and how to draw organic shapes with them. We're now ready to learn how D3 can be used to modify these elements. In [Chapter 3](/book/application_development/9781789342383/3), _Building an Interactive Scatter Plot_, we will dive into the basics of `D3.js` and create an interactive scatter plot.


Chapter 3. Building an Interactive Scatter Plot
-----------------------------------------------

Let's pretend we've started jogging and we want to visualize the data regarding our progress as a runner, with a scatter plot. We're going to have an array of objects, each with a date and distance properties. For each object in the array, we're going to create a circle in our SVG. If the `distance` property of an object is relatively high, its associated circle will be higher up on the graph. If the `date` property of an object is relatively high (a later date), its associated circle will be farther right.

By the end of this lesson, you should be able to do the following:

*   Add a link to the D3 library
*   Add an`<svg>`tag and size it with D3
*   Create some fake data for our app
*   Add SVG circles and style them
*   Create a linear scale
*   Attach data to visual elements
*   Use data attached to a visual element to affect its appearance
*   Create a time scale
*   Parse and format times
*   Set dynamic domains
*   Dynamically generate SVG elements
*   Create axes
*   Display data in a table

The complete code for this section can be found here: [https://github.com/PacktPublishing/D3.js-Quick-Start-Guide/tree/master/Chapter03](https://github.com/PacktPublishing/D3.js-Quick-Start-Guide/tree/master/Chapter03).


Adding a link to the D3 library
-------------------------------

* * *

The first thing we want to do is create a basic `index.html` file:

Copy

Now add a link to D3 at the bottom of your `<body>` tag in `index.html`. We'll put it at the bottom so that the script loads after all your other HTML elements have loaded into the browser:

Copy

Now create `app.js` in the same folder as your `index.html`. In it, we will store all of our JS code. For now, just put this code in it to see whether it works:

Copy

    console.log('this works');
    console.log(d3);

Link to it in `index.html` at the bottom of the `<body>` tag. Make sure it comes after the D3 script tag so that D3 loads before your `app.js` script:

Copy

Open `index.html` in Chrome just as we did in [Chapter 2](/book/application_development/9781789342383/2), _Using SVG to Create Images Using Code_, (**File** | **Open File**), and check your Dev Tools (**View** | **Developer** | **Developer tools**) to see whether your JavaScript files are linked correctly:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzLzlhMmEyYTY2LTg2OTUtNDY2YS1iMjZlLTkzN2E5ZWU5OGNkMg==.png)


Adding an<svg>tag and sizing it with D3
---------------------------------------

* * *

In `<indexentry content=" tag:sizing, with D3">` the `index.html`, at the top of `<body>`, before `<indexentry content=" tag:adding">` your script tags, add an `<svg>` tag:

Copy

If we examine the **Elements **tab of our dev tools, we'll `<indexentry content=" tag:adding">` see the `svg` element has `<indexentry content=" tag:sizing, with D3">` been placed. In Chrome, it has a default width/height of 300 px/150 px:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzL2Q1OGE5ZjQ3LWIxNDQtNDIxMC04YWEzLWEyNjdiZTYxZWRmZQ==.png)

In `app.js`, remove your previous `console.log` statements and create variables to hold the width and height of the `<svg>` tag:

Copy

    varWIDTH=800;
    varHEIGHT=600;

Next, we can use `d3.select()` to select a single element, in this case the `<svg>` element:

Copy

    varWIDTH=800;
    varHEIGHT=600;
    
    d3.select('svg');

The return value of `d3.select('svg')` is a D3 version of the svg element (as in jQuery), so we can chain commands onto this. Let's add some styling to adjust the height/width of the element:

Copy

    d3.select('svg')
        .style('width', WIDTH)
        .style('height', HEIGHT);

Now, when we check the dev tools, we'll see the `<svg>` element has been resized:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzLzhkZTFkNWI2LTAxYTMtNDVmZC04Y2QyLWFmOGU0NTgwM2E2Mw==.png)


Creating some fake data for our app
-----------------------------------

* * *

In `app.js`, let's create an array of `run` objects, I am storing the date as a string on purpose also, it's important that this is an array of objects, to work with D3). Here's what your `app.js` code should look like so far:

Copy

    varWIDTH=800;
    varHEIGHT=600;
    
    var runs = [
        {
            id:1,
            date:'October 1, 2017 at 4:00PM',
            distance:5.2
        },
        {
            id:2,
            date:'October 2, 2017 at 5:00PM',
            distance:7.0725
        },
        {
            id:3,
            date:'October 3, 2017 at 6:00PM',
            distance:8.7
        }
    ];
    
    d3.select('svg')
        .style('width', WIDTH)
        .style('height', HEIGHT);


Adding SVG circles and styling them
-----------------------------------

* * *

In `index.html`, add three circles to your `<svg>` element (each one will represent a run):

Copy

Create `app.css`in the same folder as `index.html`, with some styling for the circles and our `svg` element:

Copy

    circle {
        r:5;
        fill: black;
    }
    svg {
        border: 1pxsolidblack;
    }

Link to it in the head of `index.html`:

Copy

Our page should now look as follows:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzLzBhZWU1N2FjLWRjYjYtNDRmNi04OWQ2LWM5OTJiY2YyMGQ3Mw==.png)


Creating a linear scale
-----------------------

* * *

We currently have three circles in our SVG and three objects in our `runs` array. One of the best things D3 does is provide the ability to link SVG elements with data so that as the data changes so do the SVG elements. In this chapter, we're going to link each circle to an object in the `runs` array. If the `distance` property of an object is relatively high, its associated circle will be higher up on the graph. If the `date` property of an object is relatively high (a later date), its associated circle is farther right.

First, let's position the circles vertically, based on the `distance` property of the objects in our `runs` array. One of the most important things that D3 does is provide the ability to convert (or `map`) data values to visual points and vice versa. It does so using a `scale`. There are lots of different kinds of scales that handle lots of different data types, but for now we're just going to use a `linear scale`, which will map numeric data values to numeric visual points, and vice versa.

At the bottom of `app.js`, add the following:

Copy

    var yScale =d3.scaleLinear(); //create the scale

Whenever we create a scale, we need to tell it the minimum and maximum possible values that can exist in our data (this is called the `domain`). To do so for our `yScale`, add the following to the bottom of `app.js`:

Copy

    yScale.domain([0, 10]); //minimum data value is 0, max is 10

We also need to tell the scale what visual values correspond to those min/max values in the data (this is called the `range`). To do so, add the following to the bottom of `app.js`:

Copy

    //HEIGHT corresponds to min data value
    //0 corresponds to max data value
    yScale.range([HEIGHT, 0]); 

Your last three lines of code in `app.js`should now look as follows:

Copy

    var yScale = d3.scaleLinear(); //create the scale
    yScale.domain([0, 10]); //minimum data value is 0, max is 10
    //HEIGHT corresponds to min data value
    //0 corresponds to max data value
    yScale.range([HEIGHT, 0]);

In the previous snippet, the first (starting) value for the range is`HEIGHT`(600) and the second (ending) value is 0. The minimum for the data values is 0 and the max is 10. By doing this, we're saying that a data point (distance run) of 0 should map to a visual height value of`HEIGHT`(600):

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzL2RjYTJlY2JiLTA3ZWItNDEwYS1iZDM5LTI5OGQ4YmEyZjdlNA==.png)

This is because the lower the distance run (data value), the more we want to move the visual point down the _y_ axis. Remember that the _y_ axis starts with 0 at the top and increases in value as we move down vertically on the screen.

We also say that a data point (distance run) of 10 should map to a visual height of 0:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzL2FjMzNmNWFiLTE1MDItNDJhYy1iNTMxLTNlNmNmM2VmOGM3Mw==.png)

Again, this is because, as the distance run increases, we want to get back a visual value that is lower and lower so that our circles are closer to the top of the screen.

If you ever need to remind yourself what the domain/range is, you can do so by logging `yScale.domain()` or `yScale.range()`. Temporarily add the following at the bottom `app.js`:

Copy

    //you can get the domain whenever you want like this
    console.log(yScale.domain());
    //you can get the range whenever you want like this:
    console.log(yScale.range());

Our Chrome console should look as follows:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzL2RlNzExOWVjLTY3NzktNDNlYy1hMjNhLTVmYjM2YzllNmQ5Mg==.png)

When declaring the range/domain of a linear scale, we only need to specify start/end values for each. Values in between the start/end will be calculated by D3. For instance, to find out what visual value corresponds to the distance value of 5, use `yScale()`. Remove the previous two `console.log()` statements and add the following to the bottom of `app.js`:

Copy

    console.log(yScale(5)); //get a visual point from a data value

Here's what our dev console should look like in Chrome:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzL2YxNjBhNjNkLTM3NmMtNDQwZi05OTUyLTVmMjBkNTI2NDhhNA==.png)

It makes sense that this logs `300` because the data value of `5` is half way between the minimum data value of `0` and the maximum data value of `10`. The range starts at `HEIGHT` (600) and goes to `0`, so halfway between those values is 300.

So, whenever you want to convert a data point to a visual point, call `yScale()`. We can go the other way and convert a visual point to a data value by calling `yScale.invert()`. To find out what data point corresponds to a visual value of 450, remove the previous `console.log()` statement and add the following to the bottom of `app.js`:

Copy

    //get a data values from a visual point
    console.log(yScale.invert(450));

Here's what Chrome's console looks like:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzL2UyNmUyM2YzLTNhZWEtNGFiMC04ZjE5LWRjZjEyZDA2ZjFjOQ==.png)

It makes sense that this logs `2.5` because the visual value of 450 is 25% of the way from the starting visual value of 600 (`HEIGHT`)to the ending visual value of `0`. You can now delete that last `console.log()` line.


Attaching data to visual elements
---------------------------------

* * *

Now let's attach each of the JavaScript objects in our `runs` array to a circle in our SVG. Once we do this, each circle can access the data of its associated `run` object to determine its position. Add the following to the bottom of `app.js`:

Copy

    yScale.range([HEIGHT, 0]);
    yScale.domain([0, 10]);
    //selectAll is like select,
    //but it selects all elements that match the query string
    d3.selectAll('circle').data(runs);

If there were more objects in our `runs` array than there are circles, the extra objects are ignored. If there are more circles than objects, then JavaScript objects are attached to circles in the order in which they appear in the DOM until there are no more objects to attach.


Use data attached to a visual element to affect its appearance
--------------------------------------------------------------

* * *

We can change attributes for a selection of DOM elements by passing static values, and all selected elements will have that attribute set to that one specific value. Add the following temporarily to the end of `app.js`:

Copy

    d3.selectAll('circle').attr('cy', 300);

The following should be seen on your screen:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzLzg2N2M5OWJiLWVjNzEtNGZlMC04MmQyLTQzMTNiODY1ODJjZA==.png)

But now that each circle has one of our `runs` JavaScript data objects attached to it, we can set attributes on each circle using that data. We do that by passing the `.attr()` method a callback function instead of a static value for its second parameter. Remove `d3.selectAll('circle').attr('cy', 300);` and adjust the last line of `app.js` from `d3.selectAll('circle').data(runs);` to the following:

Copy

    d3.selectAll('circle').data(runs)
        .attr('cy', function(datum, index){
            returnyScale(datum.distance);
        });

If we refresh the browser, this is what we should see:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzLzY3YjI1MmZiLTBkM2YtNDU5YS1hNmNiLWIyZWQ3M2JhZmI1Yg==.png)

Let's examine what we just wrote. The callback function passed as the second parameter to `.attr()` runs on each of the visual elements selected (each of the `circle` elements in this case). During each execution of the callback, the return value of that callback function is then assigned to whatever aspect of the current element is being set (in this case the `cy` attribute).

The callback function takes two params:

*   The individual `datum` object from the `runs` array that was attached to that particular visual element when we called `.data(runs)`
*   The `index` of that `datum` in the`runs` array

In summary, what this does is loop through each `circle` in the SVG. For each `circle`, it looks at the `run` object attached to that `circle` and finds its `distance` property. It then feeds that data value into `yScale()`, which then converts it into its corresponding visual point. That visual point is then assigned to that circle's `cy` attribute. Since each data object has a different `distance` value, each `circle` is placed differently, vertically.


Creating a time scale
---------------------

* * *

Let's position the circles horizontally, based on the date that their associated run happened. First, create a time scale. This is like a linear scale, but instead of mapping numeric values to visual points, it maps dates to visual points. Add the following to the bottom of `app.js`:

Copy

    //scaleTime maps date values with numeric visual points
    var xScale =d3.scaleTime();
    xScale.range([0,WIDTH]); 
    xScale.domain([newDate('2017-10-1'), newDate('2017-10-31')]); console.log(xScale(newDate('2017-10-28'))); console.log(xScale.invert(400));

Here's what our console should look like:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzLzdhYjlhNGY3LWYzNzMtNDEyNS05N2ZiLWNhZmQ2YmZlNzliYQ==.png)

You can now remove the two `console.log()` statements.


Parsing and formatting times
----------------------------

* * *

Note that the `date` properties of the objects in our `runs` array are strings and not date objects. This is a problem because `xScale`, as with all time scales, expects its data values to be date objects. Fortunately, D3 provides us an easy way to convert strings to dates and vice versa. We'll use a specially formatted string, based on the documentation ([https://github.com/d3/d3-time-format#locale\_format](https://github.com/d3/d3-time-format#locale_format)), to tell D3 how to parse the `date` string properties of the objects in our `runs` array into actual JavaScript date objects. Add the following at the end of `app.js`:

Copy

    //this format matches our data in the runs array
    var parseTime =d3.timeParse("%B%e, %Y at %-I:%M%p"); 
    console.log(parseTime('October 3, 2017 at 6:00PM'));
    var formatTime =d3.timeFormat("%B%e, %Y at %-I:%M%p");
    //this format matches our data in the runs array
    console.log(formatTime(newDate()));

Here's our Chrome console:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzLzIzMmUzMWFmLTBhNzMtNDVlYy05NzU1LTFiOWMxNDVmNDI4OA==.png)

Let's use this when calculating `cx` attributes for our circles. Remove the last two `console.log()` statements, and add the following to the bottom of `app.js`:

Copy

    //use parseTime to convert the date string property on the datum object to a Date object.
    //xScale then converts this to a visual value
    d3.selectAll('circle')
        .attr('cx', function(datum, index){
    returnxScale(parseTime(datum.date));
        });

Here's what Chrome should look like:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzLzFjNGEwNTMyLWU2OWQtNDYwMi05MmI2LTRlNTJkMTEwZTUwNQ==.png)

In summary, this selects all of the `circle` elements. It then sets the `cx` attribute of each `circle` to the result of a callback function. That callback function runs for each `circle` and takes the `run` data object associated with that `circle` and finds its `date` property (remember it's a string, for example, `'October 3, 2017 at 6:00PM'`). It passes that string value to `parseTime()` which then turns the string into an actual JavaScript date object. That date object is then passed to `xScale()`, which converts the date into a visual value. That visual value is then used for the `cx` attribute of whichever `circle` the callback function has just run on. Since each `date` property of the objects in the `runs` array is different, the `circles` have different horizontal locations.


Setting dynamic domains
-----------------------

* * *

At the moment, we're setting arbitrary min/max values for the domains of both distance and date. D3 can find the min/max of a dataset, so that our graph displays just the data ranges we need. All we need to do is pass the min/max methods a callback that gets called for each item of data in the `runs` array. D3 uses the callback to determine which properties of the datum object to compare for min/max.

Go to this part of the code:

Copy

    var yScale =d3.scaleLinear(); //create the scaleyScale.range([HEIGHT, 0]); //set the visual range (for example 600 to 0)yScale.domain([0, 10]); //set the data domain (for example 0 to 10)

Change it to this:

Copy

    var yScale =d3.scaleLinear(); //create the scaleyScale.range([HEIGHT, 0]); //set the visual range (for example 600 to 0)var yMin =d3.min(runs, function(datum, index){
        //compare distance properties of each item in the data array
        returndatum.distance; 
    })
    var yMax =d3.max(runs, function(datum, index){
        //compare distance properties of each item in the data array
        returndatum.distance;
    })
    //now that we have the min/max of the data set for distance,
    //we can use those values for the yScale domain
    yScale.domain([yMin, yMax]);console.log(yScale.domain());

Chrome should look as follows:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzLzU2ZmY0MzBkLWFhMTAtNGY3Zi05NGIzLTE5YzkzMDQwZWE0MQ==.png)

Let's examine what we just wrote. The following code finds the minimum distance:

Copy

    var yMin = d3.min(runs, function(datum, index){
        //compare distance properties of each item in the data array
        return datum.distance; 
    })

D3 loops through the `runs` array (the first parameter) and calls the callback function (the second parameter) on each element of the array. The return value of that function is compared the return values of the callback function as it runs on the other elements. The lowest value is assigned to `yMin`. The same thing happens for `d3.max()` but with the highest value.

We can combine both the min/max functions into one `extent` function that returns an array that has the exact same structure as`[yMin, yMax]`. Let's look at the code we just wrote:

Copy

    var yScale = d3.scaleLinear(); //create the scale
    yScale.range([HEIGHT, 0]); //set the visual range (for example 600 to 0)
    var yMin = d3.min(runs, function(datum, index){
        //compare distance properties of each item in the data array
        return datum.distance;
    })
    var yMax = d3.max(runs, function(datum, index){
        //compare distance properties of each item in the data array
        return datum.distance; 
    })
    //now that we have the min/max of the data set for distance
    //we can use those values for the yScale domain
    yScale.domain([yMin, yMax]);
    console.log(yScale.domain());

Change the previous code to this:

Copy

    var yScale =d3.scaleLinear(); //create the scaleyScale.range([HEIGHT, 0]); //set the visual range (for example 600 to 0)var yDomain =d3.extent(runs, function(datum, index){
        //compare distance properties of each item in the data array
        returndatum.distance; 
    })
    yScale.domain(yDomain);

It's much shorter, right? Let's do the same for the xScale's domain. Go to this part of the code:

Copy

    //scaleTime maps date values with numeric visual points
    var xScale =d3.scaleTime(); 
    xScale.range([0,WIDTH]);
    xScale.domain([newDate('2017-10-1'), newDate('2017-10-31')]);
    
    //this format matches our data in the runs array
    var parseTime =d3.timeParse("%B%e, %Y at %-I:%M%p");
    //this format matches our data in the runs array 
    var formatTime =d3.timeFormat("%B%e, %Y at %-I:%M%p"); 

Change it to this:

Copy

    var parseTime =d3.timeParse("%B%e, %Y at %-I:%M%p");
    var formatTime =d3.timeFormat("%B%e, %Y at %-I:%M%p");
    var xScale =d3.scaleTime();
    xScale.range([0,WIDTH]);
    var xDomain =d3.extent(runs, function(datum, index){
        returnparseTime(datum.date);
    });
    xScale.domain(xDomain);

Notice we moved `parseTime` and `formatTime` up so they could be used within the `.extent()`. Here's what Chrome should look like:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzLzkxMWM5MDYyLWJkZDktNGNhOC05NGZkLThhZGY2OGIxYzQ2NQ==.png)


Dynamically generating SVG elements
-----------------------------------

* * *

Currently, we have just enough `<circle>` elements to fit our data. What if we don't want to count how many elements are in the array? D3 can create elements as needed. First, remove all `<circle>` elements from `index.html`. Your `<body>` tag should now look as follows:

Copy

In `app.js`, go to this part of the code:

Copy

    d3.selectAll('circle').data(runs)
        .attr('cy', function(datum, index){
            returnyScale(datum.distance);
        });

Modify the code to create the circles:

Copy

    //since no circles exist, we need to select('svg')
    //so that d3 knows where to append the new circles
    d3.select('svg').selectAll('circle')
        .data(runs) //attach the data as before
        //find the data objects that have not yet 
        //been attached to visual elements
        .enter()
        //for each data object that hasn't been attached,
        //append a  to the 
        .append('circle'); 
    
    d3.selectAll('circle')
        .attr('cy', function(datum, index){
            returnyScale(datum.distance);
        });

It should look exactly the same as before, but now circles are being created for each object in the `runs` array:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzL2EyZGEzZWYxLTZmZDktNDlhMy1hOTRjLTRjNjUyMzNjZjk2NQ==.png)

Here's a more in-depth explanation of what we just wrote. Take a look at the first line of the new code:

Copy

    d3.select('svg').selectAll('circle')

This might seem unnecessary. Why not just do `d3.selectAll('circle')`? Well, at the moment, there are no `circle` elements. We're going to be appending `circle` elements dynamically, so `d3.select('svg')` tells D3 where to append them. We still need `.selectAll('circle')` though, so that when we call `.data(runs)` on the next line, D3 knows what elements to bind the various objects in the `runs` array to. But there aren't any `circle` elements to bind data to. That's OK.`.enter()` finds the `run` objects that haven't been bound to any `circle` elements yet (in this case all of them). We then use `.append('circle')` to append a circle for each unbound `run` object that `.enter()` found.


Creating axes
-------------

* * *

D3 can automatically generate axes for you. Add the following to the bottom of`app.js`:

Copy

    //pass the appropriate scale in as a parameter
    var bottomAxis =d3.axisBottom(xScale);

This creates a bottom axis generator that can be used to insert an axis into any element you choose. Add the following code to the bottom of `app.js` to append a `<g>` element inside our SVG element and then insert a bottom axis inside it:

Copy

    d3.select('svg')
        .append('g') //put everything inside a group
        .call(bottomAxis); //generate the axis within the group

Here's what Chrome should look like:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzL2U1N2U1ODZhLTVhMWEtNDkwNi04NWQ3LWMyMjEyODE3YWVmNA==.png)

Display of Chrome

We want the axis to be at the bottom of the SVG, though. Modify the code we just wrote so it looks like this (note: we removed a`;` after`.call(bottomAxis)` and added`.attr('transform', 'translate(0,'+HEIGHT+')');`):

Copy

    //pass the appropriate scale in as a parameter
    var bottomAxis =d3.axisBottom(xScale); 
    d3.select('svg')
        .append('g') //put everything inside a group
        .call(bottomAxis) //generate the axis within the group
        //move it to the bottom
        .attr('transform', 'translate(0,'+HEIGHT+')'); 

Currently, our SVG clips the axis:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzLzBlZjgwMTM4LWI4Y2ItNDJlMi04MGQ0LTZkZTJlMmFjYTc2MQ==.png)

Let's alter our `svg` CSS so it doesn't clip any elements that extend beyond its bounds:

Copy

    svg {
        overflow: visible;    
    }

Now it looks good:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzLzlhOTQyNDE2LWE3N2YtNGFjNS1hNTRkLTU2OWI0YTE2ZjJlNg==.png)

The left axis is pretty similar. Add the following to the bottom of `app.js`:

Copy

    var leftAxis =d3.axisLeft(yScale);
    d3.select('svg')
        .append('g')
        //no need to transform, since it's placed correctly initially
        .call(leftAxis); 

Note: we don't need to set a `transform` attribute, since it starts out in the correct place initially:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzLzM2NGFmZDlmLWY0NDYtNDk3Yi05NTI0LTIwYmQ5ZDM1OTZlNA==.png)

It's a little tough to see, so let's add the following at the bottom of `app.css`:

Copy

    body {
        margin: 20px40px;
    }

Now our axes are complete:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzLzgyMTA1ZmU3LWE1ZDctNDVjOC04YTE5LTUyNWYyODQxZDIwNA==.png)


Displaying data in a table
--------------------------

* * *

Just for debugging purposes, let's create a table that will show all of our data. Make your `<body>` tag in `index.html` look as follows:

Copy

    
        
        
            
                
                    id
                    date
                    distance
                
            
            
            
        
        
        
    

D3 can also be used to manipulate the DOM, just like jQuery. Let's populate the`<tbody>`in that style. Add the following to the bottom of `app.js`:

Copy

    varcreateTable=function(){
        for (var i =0; i 

Add some styling for the table at the bottom of `app.css`:

Copy

    table, th, td {
       border: 1pxsolidblack;
    }
    th, td {
        padding:10px;
        text-align: center;
    }

Adjust the CSS for `svg` to add a bottom margin. This will create some space between the graph and the table:

Copy

    svg {
        overflow: visible;
        margin-bottom: 50px;
    }

Now the browser should look like this:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzL2RkNmRlMTUwLThlNDYtNGExYy05Yzk1LWZjZDIzOTA0NTJjYw==.png)


Summary
-------

* * *

At this point, you have a static scatter plot and a table that displays its data. In [Chapter 4](/book/application_development/9781789342383/4), _Making a Basic Scatter Plot Interactive_, we will be learning how to make it interactive.


Chapter 4. Making a Basic Scatter Plot Interactive
--------------------------------------------------

In the last chapter, we created a static scatter plot. In this chapter, we'll make it interactive so that we can add, update, and delete runs. You'll learn how to do the following:

*   Create a click handler
*   Remove data
*   Drag an element
*   Update data after a drag
*   Create a zoom behavior that scales elements
*   Update axes when zooming/panning
*   Update click points after a transform
*   Avoid redrawing the entire screen during rendering
*   Hide elements beyond axes

The complete code for this section can be found here: [https://github.com/PacktPublishing/D3.js-Quick-Start-Guide/tree/master/Chapter04](https://github.com/PacktPublishing/D3.js-Quick-Start-Guide/tree/master/Chapter04)[.](https://github.com/PacktPublishing/D3.js-Quick-Start-Guide/tree/master/Chapter04)


Creating a click handler
------------------------

* * *

Let's say that we want it so that when the user clicks on the `<svg>` element, it creates a new run. Add the following to the bottom of `app.js`:

Copy

    d3.select('svg').on('click', function(){
        //gets the x position of the mouse relative to the svg element
        var x =d3.event.offsetX;
        //gets the y position of the mouse relative to the svg element
        var y =d3.event.offsetY; 

Copy

        //get a date value from the visual point that we clicked on
        var date =xScale.invert(x);
        //get a numeric distance value from
        //the visual point that we clicked on
        var distance =yScale.invert(y); 
    
        //create a new "run" object
        var newRun = { 
            //generate a new id by adding 1 to the last run's id
            id: runs[runs.length-1].id+1, 
            //format the date object created above to a string
            date:formatTime(date),
            distance: distance //add the distance
        }
        runs.push(newRun); //push the new run onto the runs arraycreateTable(); //render the table
    });

Let's examine what we just wrote. Note that `d3.select('svg').on('click', function(){`sets up a click handler on the `svg` element. The anonymous function that gets passed in as the second parameter to `.on()` gets called each time the user clicks on the SVG. Once inside that callback function, we use `d3.event.offsetX` to get the _x_ position of the mouse inside the SVG, and we use `d3.event.offsetY` to get the _y_ position. We then use `xScale.invert()` and `yScale.invert()` to turn the _x_/_y_ visual points into data values (date and distance, respectively). We then use those data values to create a new run object. We create an ID for the new run by getting the ID of the last element in the `runs` array and adding 1 to it. Lastly, we push the new run on to the `runs` array and call `createTable()`.

Click on the SVG to create a new run. You might notice that `createTable()` just adds on all the run rows again:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzLzlkMTRkNWZjLTMzYjctNDRlNS05NzdjLWE0YWQ2OTI0NzhhNw==.png)

Let's alter the `createTable()` function so that when it runs, it clears out any rows previously created and re-renders everything. Add `d3.select('tbody').html('')` to the top of the `createTable` function in `app.js`:

Copy

    varcreateTable=function(){
        //clear out all rows from the table
        d3.select('tbody').html(''); 
        for (var i =0; i 

Now refresh the page and click on the SVG to create a new run. The table should then look like this:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzLzQyMjY0MTM5LWQ0ZmMtNGMzNC1hOWVmLWQ0YzM4Y2ZmMWNmOA==.png)

The only issue now is that circles aren't being created when you click on the SVG. To fix this, let's wrap the code for creating `<circle>` elements in a render function, and call `render()` immediately after it's defined:

Copy

    varrender=function(){
    
        var yScale =d3.scaleLinear();
        yScale.range([HEIGHT, 0]);
        yDomain =d3.extent(runs, function(datum, index){
            returndatum.distance;
        })
        yScale.domain(yDomain);
    
        d3.select('svg').selectAll('circle')
            .data(runs)
            .enter()
            .append('circle');
    
        d3.selectAll('circle')
            .attr('cy', function(datum, index){
                returnyScale(datum.distance);
            });
    
        var parseTime =d3.timeParse("%B%e, %Y at %-I:%M%p");
        var formatTime =d3.timeFormat("%B%e, %Y at %-I:%M%p");
        var xScale =d3.scaleTime();
        xScale.range([0,WIDTH]);
        xDomain =d3.extent(runs, function(datum, index){
            returnparseTime(datum.date);
        });
        xScale.domain(xDomain);

Copy

    d3.selectAll('circle')
            .attr('cx', function(datum, index){
                returnxScale(parseTime(datum.date));
            });
    
    }
    render();

If you refresh the browser, you'll see an error in the console. This is because`bottomAxis` and `leftAxis` use `xScale` and `yScale` that are now scoped to exist only inside the `render()` function. For future use, let's move `xScale` and `yScale` out of the render function along with the code for creating the domains/ranges:

Copy

    var parseTime =d3.timeParse("%B%e, %Y at %-I:%M%p");
    var formatTime =d3.timeFormat("%B%e, %Y at %-I:%M%p");
    var xScale =d3.scaleTime();
    xScale.range([0,WIDTH]);
    xDomain =d3.extent(runs, function(datum, index){
        returnparseTime(datum.date);
    });
    xScale.domain(xDomain);
    
    var yScale =d3.scaleLinear();
    yScale.range([HEIGHT, 0]);
    yDomain =d3.extent(runs, function(datum, index){
        returndatum.distance;
    })
    yScale.domain(yDomain);
    varrender=function(){
    
        //since no circles exist,
        //we need to select('svg') so that 
        //d3 knows where to append the new circles
        d3.select('svg').selectAll('circle') 
            //attach the data as before
            .data(runs) 
            //find the data objects that have not yet
            //been attached to visual elements
            .enter()
            //for each data object that hasn't been attached, 
            //append a  to the 
            .append('circle');

Copy

    d3.selectAll('circle')
            .attr('cy', function(datum, index){
                returnyScale(datum.distance);
            });
    
        d3.selectAll('circle')
            .attr('cx', function(datum, index){
                //use parseTime to convert 
                //the date string property on the datum object 
                //to a Date object, 
                //which xScale then converts to a visual value
                returnxScale(parseTime(datum.date)); 
            });
    
    }
    render();

Now go to the bottom of `app.js` and add a line to call `render()` inside our `<svg>` click handler:

Copy

    var newRun = {
        id: runs[runs.length-1].id+1,
        date: formatTime(date),
        distance: distance
    }
    runs.push(newRun);
    createTable();
    render(); //add this line

Now when you click the SVG, a circle will appear:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzLzE5M2JiYzQyLWRmYjgtNDJkNi05MWUxLWVkM2EwYTkyMGFiMw==.png)


Removing data
-------------

* * *

Let's set up a click handler on all `<circle>` elements so that when the user clicks on `<circle>`, D3 will remove that circle and its associated data element from the array. Add the following code at the bottom of the `render` function declaration we wrote in the last section. We do this so that the click handlers are attached _after_ the circles are created:

Copy

    //put this at the bottom of the render function, 
    //so that click handlers are attached when the circle is createdd3.selectAll('circle').on('click', function(datum, index){
        //stop click event from propagating to 
        //the SVG element and creating a run
        d3.event.stopPropagation(); 
        //create a new array that has removed the run 
        //with the correct id. Set it to the runs var
        runs =runs.filter(function(run, index){ 
            returnrun.id!=datum.id;
        });
        render(); //re-render dotscreateTable(); //re-render table
    });

Let's examine the previous code. The first line selects all `<circle>` elements and creates a click handler on each of them. However, `d3.event.stopPropagation();` prevents the click from bubbling up the DOM to the SVG. If we don't add it, the click handler on the SVG will fire as well, when we click on a circle. This would create an additional run every time we try to remove a run. Next, we call the following:

Copy

    runs = runs.filter(function(run, index){
     return run.id != datum.id;
    });

This loops through the `runs` array and filters out any objects that have an `id` property that matches the `id` property of `datum` that is associated with `<circle>` that was clicked. Notice that the callback function in `.on('click', function(datum, index){` takes two parameters: `datum`, the run object associated with that `<circle>` , and the `index` of the run object in the `runs` array.

Once we've filtered out the correct run object from the `runs` array, we call `render()` and `createdTable()` to re-render the graph and the table.

But if we click on the middle circle and examine the **Elements** tab of the Developer Tools, we'll see that the `<circle>` element hasn't been removed:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzLzVkYWNlNjk5LTM3MWEtNGMzNy1iMGM5LTQ3YTIzNDljMjM5Mg==.png)

Elements tab showing the <circle> element

In the previous screenshot, it appears as though there are only two circles, but really the middle one has had its `cx` set to 800 and its `cy` set to 0. It's overlapping the other circle in the same position. This is because we've removed the second element in the `runs` array. When we re-render the graph, the `runs` array only has two objects; the second run object used to be the third run object before we removed the middle run. Now that it's the second run object, the second `<circle>` is assigned its data. The third circle still has its old data assigned to it, so both the second and the third circle have the same data and are therefore placed in the same location.

Let's put the circles in `<g>` so that it's easy to clear out all the circles and re-render them when we remove a run. This way we won't have any extra `<circle>` elements lying around when we try to remove them. This approach is similar to what we do when re-rendering the table. Adjust your `<svg>` element in `index.html` so it looks as follows:

Copy

Now we can clear out the `<circle>` elements each time `render()` is called. This is a little crude, but it'll work for now. Later on, we'll do things in a more elegant fashion. At the top of the `render()` function declaration, add `d3.select('#points').html('');` and adjust the next line from `d3.select('svg').selectAll('circle')` to `d3.select('#points').selectAll('circle')`:

Copy

    //adjust the code at the top of your render function
     //clear out all circles when renderingd3.select('#points').html('');
     //add circles to #points group, not svg d3.select('#points').selectAll('circle') .data(runs) .enter() .append('circle');

Now if we click on the middle circle, the element is removed from the DOM:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzLzQyNDZkN2YzLTJlZTItNDNiZC05ZTVmLWEyMTUzMTc5ZDYxNg==.png)

Removing the element from the DOM

If you try to delete all the circles and then add a new one, you'll get an error:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzL2NkYWJjMDkwLTIxYmItNDQ4Yy1iYTQ3LWFkZjZmZWU1M2U0Mg==.png)

Displaying the error you get when deleting all the circles and adding a new one

This is because our code for creating `newRun` in the SVG click handler needs some work:

Copy

    var newRun = { //create a new "run" object
        //generate a new id by adding 1 to the last run's id
        id: runs[runs.length-1].id+1, 
        //format the date object created above to a string
        date:formatTime(date), 
        distance: distance //add the distance
    }

This is because when there are no run elements in the `runs` array, `runs[runs.length-1]` tries to access an element at index `-1` in the array. Inside the `<svg>` click handler, let's put in a little code to handle when the user has deleted all runs and tries to add a new one:

Copy

    //inside svg click handlervar newRun = {
        //add this line
        id: ( runs.length>0 ) ? runs[runs.length-1].id+1:1, 
        date:formatTime(date),
        distance: distance
    }

Here's what Chrome should look like now if you delete all the runs and then try to add a new one:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzLzliNzFkZjVmLTZkOTItNGU1ZC05NDAwLTY0YmNjZGUxMDk0Yg==.png)

Lastly, let's put in some CSS, so we know we're clicking on a circle. First, add `transition: r 0.5s linear, fill 0.5s linear;` to the CSS code you've already written for `circle`:

Copy

    circle {
        r: 5;
        fill: black;
        /* add this transition to original code */
        transition: r 0.5slinear, fill0.5slinear; 
    }

Then add this to the bottom of `app.css`:

Copy

    /* add this css for the hover state */circle:hover {
        r:10;
        fill: blue;
    }

Here's what a circle should look like when you hover over it:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzLzdiMTE4NTcwLWVkOGUtNDFjYy05OGRjLTg3OGY4YWMwZDUwYQ==.png)


Dragging an element
-------------------

* * *

We want to be able to update the data for a run by dragging the associated circle. To do this, we'll use a behavior, which you can think of as a combination of multiple event handlers. For a drag behavior, there are three callbacks:

*   When the user starts to drag
*   Each time the user moves the cursor before releasing the _mouse_ button
*   When the user releases the _mouse_ button

There are two steps whenever we create a behavior:

1.  Create the behavior
2.  Attach the behavior to one or more elements

Put the following code at the bottom of the `render()` function declaration:

Copy

    //put this code at the end of the render functionvardrag=function(datum){
        var x =d3.event.x;
        var y =d3.event.y;
        d3.select(this).attr('cx', x);
        d3.select(this).attr('cy', y);
    }
    var dragBehavior =d3.drag()    
        .on('drag', drag);
    d3.selectAll('circle').call(dragBehavior);

You can now drag the circles around, but the data doesn't update:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzLzNiOThkZTA4LTFhYmUtNDI4Yi1hY2YzLWQ1NGU3MDIxZjgxMg==.png)

Let's examine how this code works:

Copy

    var drag = function(datum){
     var x = d3.event.x;
     var y = d3.event.y;
     d3.select(this).attr('cx', x);
     d3.select(this).attr('cy', y);
    }

This `drag` function will be used as a callback anytime the user moves the cursor before releasing the mouse button. It gets the _x_ and _y_ coordinates of the mouse and sets the `cx` and `cy` values of the element being dragged (`d3.select(this)`) to those coordinates.

Next, we generate a drag behavior that will, at the appropriate time, call the `drag` function that was just explained:

Copy

    var dragBehavior = d3.drag()
     .on('drag', drag);

Lastly, we attach that behavior to all the `<circle>` elements:

Copy

    d3.selectAll('circle').call(dragBehavior);


Updating data after a drag
--------------------------

* * *

Now we're going to add functionality so that when the user releases the mouse button, the data for the run object associated with the circle being dragged gets updated.

First, let's create the callback function that will get called when the user releases the mouse button. Toward the bottom of the `render()` function declaration, add the following code just above `var drag = function(datum){`:

Copy

    var dragEnd = function(datum){
        var x = d3.event.x;
        var y = d3.event.y;
    
        var date = xScale.invert(x);
        var distance = yScale.invert(y);
    
        datum.date = formatTime(date);
        datum.distance = distance;
        createTable();
    }

Now attach that function to `dragBehavior` so that it is called when the user stops dragging a circle. Look at the following code:

Copy

    var dragBehavior = d3.drag()
        .on('drag', drag);

Change it to this:

Copy

    var dragBehavior = d3.drag()
        .on('drag', drag)
        .on('end', dragEnd);

Now, once you stop dragging a circle around, you should see the data in the table change:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzLzM1NTA3Y2FiLWRlNWYtNDQwNS05NGRlLWFlYjMwYmFjMGI4OQ==.png)

Let's change the color of a circle while it's being dragged too. Add this to the bottom of `app.css`:

Copy

    circle:active {
        fill: red;
    }

When you drag a circle, it should turn red.


Creating a zoom behavior that scales elements
---------------------------------------------

* * *

Another behavior we can create is the zooming/panning ability. Once this functionality is complete, you will be able to zoom in and out on different parts of the graph by doing one of the following:

*   A two-finger drag on a trackpad
*   Rotating your mouse wheel
*   Pinching/spreading on a trackpad

You will also be able to pan left, right, up, and down on the graph by clicking and dragging on the SVG element.

Put the following code at the bottom of `app.js`:

Copy

    var zoomCallback = function(){
        d3.select('#points').attr("transform", d3.event.transform);
    }

This is the callback function that will be called when the user attempts to zoom or pan. All it does is take the zoom or pan action and turn it into a `transform` attribute that gets applied to the `<g id="points"></g>` element that contains the circles. Now add the following code to the bottom of `app.js` to create the `zoom` behavior and attach it to the `svg` element:

Copy

    var zoom = d3.zoom()
        .on('zoom', zoomCallback);
    d3.select('svg').call(zoom);

Now, if we zoom out, the graph should look something like this:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzLzEwNjAwYmMwLTY3NmItNDljMC04YmE4LTAwOWE2YzcwOTBmYQ==.png)


Updating axes when zooming and panning
--------------------------------------

* * *

Now when we zoom, the points move in/out. When we pan, they move vertically/horizontally. Unfortunately, the axes don't update accordingly. Let's first add IDs to the `<g>` elements that contain them. Find the following code:

Copy

    var bottomAxis = d3.axisBottom(xScale);
    d3.select('svg')
        .append('g')
        .call(bottomAxis)
        .attr('transform', 'translate(0,'+HEIGHT+')');
    var leftAxis = d3.axisLeft(yScale);
    d3.select('svg')
        .append('g')
        .call(leftAxis);

Add `.attr('id', 'x-axis')` after the first `.append('g')`, and `.attr('id', 'y-axis')` after the second `.append('g')`:

Copy

    d3.select('svg')
        .append('g')
        .attr('id', 'x-axis') //add an id
        .call(bottomAxis)
        .attr('transform', 'translate(0,'+HEIGHT+')');
    var leftAxis = d3.axisLeft(yScale);
    d3.select('svg')
        .append('g')
        .attr('id', 'y-axis') //add an id
        .call(leftAxis);

Now let's use those IDs to adjust the axes when we zoom. Find this code:

Copy

    var zoomCallback = function(){
        d3.select('#points').attr("transform", d3.event.transform);
    }

Add the following to the end of the function declaration:

Copy

    d3.select('#x-axis')
        .call(bottomAxis.scale(d3.event.transform.rescaleX(xScale)));
    d3.select('#y-axis')
        .call(leftAxis.scale(d3.event.transform.rescaleY(yScale)));

Now `zoomCallback` should look as follows:

Copy

    var zoomCallback = function(){
        d3.select('#points').attr("transform", d3.event.transform);
        d3.select('#x-axis')
          .call(bottomAxis.scale(d3.event.transform.rescaleX(xScale)));
        d3.select('#y-axis')
          .call(leftAxis.scale(d3.event.transform.rescaleY(yScale)));
    }

There are two things to note about the previous code:

*   `bottomAxis.scale()` tells the axis to redraw itself.
*   `d3.event.transform.rescaleX(xScale)` returns a value indicating how the bottom axis should rescale.

Now when you zoom out, the axes should redraw themselves:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzLzA5NTUzNmIwLTExNzktNDRiMi05ZDRjLTYxNzE5NDVkZjk2Yw==.png)


Updating click points after a transform
---------------------------------------

* * *

Try zooming and panning and then clicking on the SVG to create a new run. You'll notice it's in the wrong place. That's because the SVG click handler has no idea that a zoom or pan has happened. Currently, if you click on the visual point, no matter how much you may have zoomed or panned, the click handler still converts it as if you had never zoomed or panned.

When we zoom, we need to save the transformation information to a variable so that we can use it later to figure out how to properly create circles and runs. Find the `zoomCallback` declaration and add `var lastTransform = null` right before it. Then add `lastTransform = d3.event.transform;` to the beginning of the function declaration. It should look as follows:

Copy

    var lastTransform = null; //add this
    var zoomCallback = function(){
        lastTransform = d3.event.transform; //add this
        d3.select('#points').attr("transform", d3.event.transform);
        d3.select('#x-axis')
          .call(bottomAxis.scale(d3.event.transform.rescaleX(xScale)));
        d3.select('#y-axis')
          .call(leftAxis.scale(d3.event.transform.rescaleY(yScale)));
    }

Now whenever the user zooms or pans the transformation data that was used to shrink or move the SVG and axes is saved in the `lastTransform` variable. Use that variable when clicking on the SVG.

Find these two lines at the beginning of the SVG click handler:

Copy

    var x = d3.event.offsetX;
    var y = d3.event.offsetY;

Change them to the following:

Copy

    var x = lastTransform.invertX(d3.event.offsetX);
    var y = lastTransform.invertY(d3.event.offsetY);

Your click handler should look like this now:

Copy

    d3.select('svg').on('click', function(){
        var x = lastTransform.invertX(d3.event.offsetX); //adjust this
        var y = lastTransform.invertY(d3.event.offsetY); //adjust this
    
        var date = xScale.invert(x)
        var distance = yScale.invert(y);
    
        var newRun = {
            id: ( runs.length > 0 ) ? runs[runs.length-1].id+1 : 1,
            date: formatTime(date),
            distance: distance
        }
        runs.push(newRun);
        createTable();
        render();
    });

But now click before any zoom is broken, since `lastTransform` will be null:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzLzgyZmI0NTJlLTlmNjMtNDMwNS1iYmRhLWJjMzM0OTY2YzFmZg==.png)

Find the code that we just wrote for the SVG click handler:

Copy

    var x = lastTransform.invertX(d3.event.offsetX);
    var y = lastTransform.invertY(d3.event.offsetY);

Adjust it so it looks as follows:

Copy

    var x = d3.event.offsetX;
    var y = d3.event.offsetY;
    
    if(lastTransform !== null){
        x = lastTransform.invertX(d3.event.offsetX);
        y = lastTransform.invertY(d3.event.offsetY);
    }

Now initially, `x` and `y` are set to `d3.event.offsetX` and `d3.event.offsetY`, respectively. If a zoom or pan occurs, `lastTransform` will not be null, so we overwrite `x` and `y` with the transformed values.

Add a new run initially:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzLzM5ODI0MjdkLTU4YzAtNDhmZi05Zjg5LTBkMzIzN2YxNjA4Nw==.png)

Now pan right and add a new point:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzL2RiNjI2MDM5LTEyNTgtNDg1YS05YTM4LTMwNWE5OTY1NzYzNw==.png)


Avoiding redrawing the entire screen during rendering
-----------------------------------------------------

* * *

At the moment, every time we call `render()`, we wipe all `<circle>` elements from `<svg>`. This is inefficient. Let's just remove the ones we don't want

At the top of the `render()` function, assign `d3.select('#points').selectAll('circle').data(runs)` to a variable, so we can use it later. This helps preserve how DOM elements are assigned to data elements in the next sections. Find this at the top of the `render()` function declaration:

Copy

    d3.select('#points').html('');
    d3.select('#points').selectAll('circle')
     .data(runs)
     .enter()
     .append('circle');

Change it to this:

Copy

    d3.select('#points').html('');
    var circles = d3.select('#points')
     .selectAll('circle')
     .data(runs);
    circles.enter().append('circle');

Next, remove the `d3.select('#points').html('');` line. We'll use `.exit()` to find the selection of circles that haven't been matched with data, and then we'll use `.remove()` to remove those circles. Add the following after the last line we just wrote (`circles.enter().append('circle');`):

Copy

    circles.exit().remove();

Reload the page, click on the center (second) circle. You'll notice it looks as if the circle disappears, and the circle in the upper-right briefly gains a hover state and then shrinks back down. That's not really what's happening.

If we click on the middle circle (second), it deletes the second run object in the `runs` array, and the third run object moves down to replace it in second place. We now only have an array of two run objects: the first and what used to be the third (but is now the second). When `render()` gets called again, what was the middle (second) circle gets assigned to what used to be the third run object in the `runs` array (but is now the second). This "run" object used to be assigned to the third circle, which was in the upper right. But now, since there are only two runs, that third (upper-right) circle gets deleted when we call `circles.exit().remove();`. The second circle's data has changed now, and it jumps to the upper–right corner to match that data. It used to have a hover state, but all of a sudden it's moved out from under the cursor, so it shrinks back down to normal size and becomes black.

To avoid these effects, we need to make sure that each circle stays with the data it used to be assigned to when we call `render()`. To do this, we can tell D3 to map `<circles>` to datum by ID, rather than index, in the array. At the top of the `render()` function, find this code:

Copy

    var circles = d3.select('#points')
     .selectAll('circle')
     .data(runs);

Change it to this:

Copy

    var circles = d3.select('#points')
     .selectAll('circle')
     .data(runs, function(datum){
     return datum.id
    });

This tells D3 to use the `id` property of each run object when determining which `<circle>` element to assign the data object to. It basically assigns that `id` property of the run object to the `<circle>` element initially. That way, when the second run object is deleted, `circles.exit().remove();` will find the circle that had the corresponding ID (the middle circle) and remove it.

Now clicking on the middle circle should work correctly.


Hiding elements beyond an axis
------------------------------

* * *

If you pan or zoom extensively, you'll notice that the circles are visible beyond the bounds of the axes:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzL2YwMGU5NGZhLWZkNjUtNDhjZC04MTlkLWZmM2Q2ZjY1MDZmZA==.png)

To hide elements once they get beyond an axis, we can just add an outer SVG with `id="container"` around our current `<svg>` element in `index.html`:

Copy

Now replace all `d3.select('svg')` code with `d3.select('#container')`. You can perform a find-and-replace. There should be five instances to change:

Copy

    d3.select('#container')
        .style('width', WIDTH)
        .style('height', HEIGHT);
    
    //
    // lots of code omitted here, including render() declaration...
    //
    
    var bottomAxis = d3.axisBottom(xScale);
    d3.select('#container')
        .append('g')
        .attr('id', 'x-axis')
        .call(bottomAxis)
        .attr('transform', 'translate(0,'+HEIGHT+')');
    
    var leftAxis = d3.axisLeft(yScale);
    d3.select('#container')
        .append('g')
        .attr('id', 'y-axis')
        .call(leftAxis);
    
    //
    // code for create table omitted here...
    //
    
    d3.select('#container').on('click', function(){
        //
        // click handler functionality omitted
        //
    });
    
    //
    // zoomCallback code omitted here
    //
    
    var zoom = d3.zoom()
        .on('zoom', zoomCallback);
    d3.select('#container').call(zoom); 

And, lastly, adjust CSS to replace `svg {` with `#container {`:

Copy

    #container {
        overflow: visible;
        margin-bottom: 50px;
    }

Now circles should be hidden once they move beyond the bounds of the inner `<svg>` element:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzLzdiY2E1YzRjLTZmNTUtNGZiOC1hNTRlLTQ0NjQ3MjVhMWRhZg==.png)


Summary
-------

* * *

In this chapter, we've learned the basics of D3 and have created a fully interactive scatter plot. In the next chapter, we'll learn how to use AJAX to make an asynchronous request that will populate a bar graph.


Chapter 5. Creating a Bar Graph Using a Data File
-------------------------------------------------

**AJAX** stands for **Asynchronous JavaScript And XML**. Basically, what we can do is use JavaScript to load data into the page after it has loaded. This is a great way to generate a graph based on user interaction. In this chapter, we'll use AJAX to build a bar graph. By the end of the chapter, you should be able to do the following:

*   Use AJAX to make an asynchronous call to an external data file
*   Create a bar graph

The complete code for this section can be found here: [https://github.com/PacktPublishing/D3.js-Quick-Start-Guide/tree/master/Chapter05](https://github.com/PacktPublishing/D3.js-Quick-Start-Guide/tree/master/Chapter05).


Setting up our application
--------------------------

* * *

Let's create our standard setup in `index.html`:

Copy

Now add the following code to `app.js`:

Copy

    varWIDTH=800;
    varHEIGHT=600;
    
    d3.select('svg')
        .style('width', WIDTH)
        .style('height', HEIGHT);

Now add the following code to `app.css`:

Copy

    svg {
        border:1pxsolidblack;
    }

This is what we should have:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzLzQ2YzAwYjUzLTY3ZGItNGMyOC1hYzBiLThjMDZjZjY4NGYzMQ==.png)


Creating an external file to hold our data
------------------------------------------

* * *

Let's create a `data.json` file, which will hold fake data regarding how often job posts require certain skills. This should be the contents of the file:

Copy

    [
      {
        "name": "HTML",
        "count": 21
      },
      {
        "name": "CSS",
        "count": 17
      },
      {
        "name": "Responsive Web Design",
        "count": 17
      },
      {
        "name": "JavaScript",
        "count": 17
      },
      {
        "name": "Git",
        "count": 16
      },
      {
        "name": "Angular.js",
        "count": 9
      },
      {
        "name": "Node.js",
        "count": 9
      },
      {
        "name": "PostgreSQL",
        "count": 8
      },
      {
        "name": "Agile Project Management",
        "count": 8
      },
      {
        "name": "MongoDB",
        "count": 7
      },
      {
        "name": "Trello",
        "count": 7
      },
      {
        "name": "Testing / TDD",
        "count": 7
      },
      {
        "name": "jQuery",
        "count": 7
      },
      {
        "name": "User Testing",
        "count": 6
      },
      {
        "name": "MySQL",
        "count": 6
      },
      {
        "name": "PHP",
        "count": 6
      },
      {
        "name": "React.js",
        "count": 6
      },
      {
        "name": "AJAX",
        "count": 6
      },
      {
        "name": "Express.js",
        "count": 5
      },
      {
        "name": "Heroku",
        "count": 5
      },
      {
        "name": "Wireframing",
        "count": 5
      },
      {
        "name": "Sass/SCSS",
        "count": 5
      },
      {
        "name": "Mobile Web",
        "count": 4
      },
      {
        "name": "Rails",
        "count": 4
      },
      {
        "name": "WordPress",
        "count": 4
      },
      {
        "name": "Drupal",
        "count": 3
      },
      {
        "name": "Ruby",
        "count": 3
      },
      {
        "name": "Ember.js",
        "count": 3
      },
      {
        "name": "Python",
        "count": 3
      },
      {
        "name": "Amazon EC2",
        "count": 2
      },
      {
        "name": "Computer Science degree",
        "count": 1
      },
      {
        "name": "Backbone.js",
        "count": 1
      },
      {
        "name": "Less",
        "count": 1
      },
      {
        "name": "Prototyping",
        "count": 1
      },
      {
        "name": "Redis",
        "count": 1
      }
    ]


Making an AJAX request
----------------------

* * *

Now we're going to use JavaScript to make a request for some data.

### Writing the basic code

D3 has lots of different methods for making AJAX requests to files of different data types:

Copy

    d3.json('path').then(function(data){
        //do something with the json data here
    });
    d3.csv('path').then(function(data){
        //do something with the csv data here
    });
    d3.tsv('path').then(function(data){
        //do something with the tsv data here
    });
    d3.xml('path').then(function(data){
        //do something with the xml data here
    });
    d3.html('path').then(function(data){
        //do something with the html data here
    });
    d3.text('path').then(function(data){
        //do something with the text data here
    });

Since our data is in JSON format, we'll use the first kind of call. Add the following to the end of `app.js`:

Copy

    d3.json('data.json').then(function(data){ console.log(data); });

### Handling file access

If you opened the `index.html` file in Chrome directly, instead of serving it on a web server, you'll notice we've encountered an error. Check your developer console:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzLzgyMDFjZGEwLWYzYjgtNGM4NS1hZGUzLWU5YWRkOWYyNzEzZQ==.png)

The issue here is that web browsers are not supposed to make AJAX requests to files on your computer. If they could, this would be a huge security flaw because any website could access files on your computer. Let's create a basic file server. To do this, you'll need to `installNode.js` ([https://nodejs.org/en/](https://nodejs.org/en/)). Once that's done, open your computer's Terminal:

*   For Mac: command + _Space_, and then type `terminal` and hit Ent_er_.
*   For Windows: click **`Start`**, type `cmd`,and hit _Enter_.

Next, type the following into your Terminal:

Copy

    npm install -g http-server

If you get error messages, try this:

Copy

    sudo npm install -g http-server

This installs a basic `http-server` that was built using `Node.js`. To run it, use the Terminal to navigate to the directory where you saved your code (type `cd` to change folders in the Terminal) and run the following:

Copy

    http-server .

You should see something such as this:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzLzJjNmM1ZDliLWY1Y2MtNGJlYi05NzFmLWY2Y2JhYTI5NjA1ZA==.png)

Now go to `http://localhost:8080/` in your browser. You should now see that your AJAX call is succeeding (if you have issues, hold down shift and hit the refresh button to force the browser to reload all files that may have been cached):

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzL2ExMzJiZTY4LTc2NmEtNDYzMC05ZTA0LTM0ZWUwYTM0MDhjYg==.png)


Using AJAX data to create SVG elements
--------------------------------------

* * *

Now that our AJAX calls are succeeding, let's start building our app. From here on out, it's all basic JavaScript and D3. Note that everything we'll write for the rest of this lesson is done within the success callback of our AJAX request. In production, we might want to move this code elsewhere, but for now this is easier for learning. Let's create some rectangles for our bar graph. The bottom of `app.js` (the callback to the AJAX request) should now look as follows:

Copy

    d3.json('data.json').then(function(data){
        d3.select('svg').selectAll('rect')
            .data(data)
            .enter()
            .append('rect');
    });

Our **Elements** tab in our dev tools should look something like this:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzL2JiNTU1MDFlLWZiMjQtNDM4OS04ODc4LThlMjRiNDM5YmM4ZA==.png)


Adjusting the height and the width of the bars
----------------------------------------------

* * *

Let's create a scale that maps the `count` property of each element in `data` to a visual height for the corresponding bar. We'll use a linear scale. Remember to map `HEIGHT` of the graph to a very low data point and the top of the graph (`0` in the range) map to a very high data value. Add this code to the bottom of the AJAX callback:

Copy

    var yScale =d3.scaleLinear();
    yScale.range([HEIGHT, 0]);
    var yMin =d3.min(data, function(datum, index){
        returndatum.count;
    })
    var yMax =d3.max(data, function(datum, index){
        returndatum.count;
    })
    yScale.domain([yMin, yMax]);

We could use `d3.extent`, but we're going to need the individual min values later on. Immediately after the previous code, let's tell D3 to adjust the height of the rectangles using the `yScale`. Remember that the _y_ axis is flipped. A low data value produces a high range value. But even though the range is high, the bar itself should be small. We'll need to re-flip the values just for height so that a low data value produces a small bar and a high data value produces a large bar. To do this, let's subtract whatever the range point is from `HEIGHT` of the graph. This way, if `yScale(datum.count)` produces, say, 500, the height of the bar will be 100. We can use `yScale(datum.count)` normally when adjusting the position of the bars later. Add the following to the bottom of the AJAX callback:

Copy

    d3.selectAll('rect')
        .attr('height', function(datum, index){
            returnHEIGHT-yScale(datum.count);
        });

Now our rectangles have height, but no width:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzLzkxZTgyZDU3LTUxOGItNDU1My04NzIzLTkwZWJmZTIwOTI1MA==.png)

At the bottom of `app.css`, let's give all our bars the same width:

Copy

    rect {
        width: 15px;
    }

Here's what we should see in Chrome now:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzLzgxMTk4NjZhLTM3NTctNGFkYS1iMjMwLWQyN2Y4OTJiOTU2Yg==.png)


Adjusting the horizontal and the vertical placement of the bars
---------------------------------------------------------------

* * *

Our bars all overlap one another at the moment. Let's space them out by mapping _x_'s position to index in the data array. Add the following to the bottom of the AJAX callback:

Copy

    var xScale =d3.scaleLinear(); xScale.range([0, WIDTH]); xScale.domain([0, data.length]); d3.selectAll('rect') .attr('x', function(datum, index){ returnxScale(index); });

This maps indices in the array to horizontal range points. Chrome should look as follows:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzLzkzOWUwZjhjLWE0MjUtNGIwMy1hNWE2LWMzZTBmMDFhNDRiMQ==.png)

Now let's move the bars so they grow from the bottom, as opposed to hanging from the top. Add the following to the end of the AJAX callback:

Copy

    d3.selectAll('rect')
        .attr('y', function(datum, index){
            return yScale(datum.count);
        });

Using our `yScale` function, a high data value produces a low range value, which doesn't push a large bar down much. A low data point produces a high range value, which pushes a small bar down a lot.

Our last few bars don't have any height, because we've mapped the minimum count property of our data to a visual range value of 0 in `yScale`. Let's adjust the last line of this code:

Copy

    var yScale =d3.scaleLinear();
    yScale.range([HEIGHT, 0]);
    var yMin =d3.min(data, function(datum, index){
        returndatum.count;
    })
    var yMax =d3.max(data, function(datum, index){
        returndatum.count;
    })
    yScale.domain([yMin, yMax]);

We will change it to this code:

Copy

    var yScale =d3.scaleLinear();
    yScale.range([HEIGHT, 0]);
    var yMin =d3.min(data, function(datum, index){
        returndatum.count;
    })
    var yMax =d3.max(data, function(datum, index){
        returndatum.count;
    })
    yScale.domain([yMin-1, yMax]); //adjust this line

Now the domain minimum is one less than what's actually in our data set. Domains with the original minimum are treated as higher values than what's expected for the minimum of the graph. We get this:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzLzJiYTIxMzhlLWI0NDQtNDJiYS1hMDhlLWQ1MDQwYzc0ODg3OQ==.png)


Making the width of the bars dynamic
------------------------------------

* * *

Currently, our bars have a fixed width. No matter how many elements we have, they have a 15 px width. If we had more data elements, the bars could overlap. Let's change this. Since each `rect` will be the same width, no matter what the data is, we can just assign `width` a computed value. Add the following to the end of the AJAX callback:

Copy

    d3.selectAll('rect')
        .attr('width', WIDTH/data.length);

Now let's adjust our `rect` CSS so our bars are more visible:

Copy

    rect {
        /*  remove the width rule that was here */stroke:white;
        stroke-width:1px;
    }

The output will be shown as follows:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzL2RmZjk5MTMxLWQxNWQtNDk3Yi05MTVjLTNjYjllYTQ4ZDM1Yw==.png)


Changing the color of the bar based on data
-------------------------------------------

* * *

Right now, the bars are black. A linear scale will interpolate between colors, just like a regular number. Add the following to the end of the AJAX callback:

Copy

    var yDomain =d3.extent(data, function(datum, index){
        returndatum.count;
    })
    var colorScale =d3.scaleLinear();
    colorScale.domain(yDomain)
    colorScale.range(['#00cc00', 'blue'])
    d3.selectAll('rect')
        .attr('fill', function(datum, index){
            returncolorScale(datum.count)
        })

Notice that we calculate they Domain using `d3.extent` so that the real minimum of the data set is used to map `#00cc00`:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzLzViY2Y4MzVmLTlhOWItNDFjOS1hMzQ4LTY3ZTM1NGQ1ODAwMg==.png)


Adding axes
-----------

* * *

The left axis is the same as shown in [Chapter 4](/book/application_development/9781789342383/4), _Making a Basic Scatter Plot Interactive_. Add this code to the bottom of the AJAX callback:

Copy

    var leftAxis =d3.axisLeft(yScale);
    d3.select('svg')
        .append('g').attr('id', 'left-axis')
        .call(leftAxis);

To create the bottom axis, we need to be able to map strings to points on a domain. We'll use a band scale for this, which just divides up the range into equal parts and maps it to an array of discrete values (values that can't be interpolated, for example, strings). Add this code to the bottom of the AJAX callback:

Copy

    var skillScale =d3.scaleBand();
    var skillDomain =data.map(function(skill){
        returnskill.name
    });
    skillScale.range([0, WIDTH]);
    skillScale.domain(skillDomain);

Notice we use `data.map()`. This is regular JavaScript that simply loops through an array and modifies each element based on the given function. It then returns the resulting array, leaving the original array in tact. In the previous example, `skillDomain` will be an array containing the various name properties of each of the data elements.

Once we have an array of each of the skills, we use this as the domain and map each skill to a point within the range. Remember the point in the range is created by dividing up the full range equally based on the number of elements in the domain.

Now that we have a scale that maps each skill text to a point in the _x_ range, we can create the bottom axis as before. Add this code to the bottom of the AJAX callback:

Copy

    var bottomAxis =d3.axisBottom(skillScale);
    d3.select('svg')
        .append('g').attr('id', 'bottom-axis')
        .call(bottomAxis)
        .attr('transform', 'translate(0,'+HEIGHT+')');

We still need to stop the `<svg>`element from clipping the axes. Change the CSS for `svg` in `app.css`:

Copy

    svg {
        overflow: visible;
    }

The following is the result:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzL2Y0YzNmYTg3LTE2MTItNDA4Yi1hMmNiLTBlNjM3NTk0MTBhOQ==.png)

The bottom axis text is all cluttered, though. Let's add some CSS to bottom of `app.css` to fix this:

Copy

    #bottom-axistext {
        transform:rotate(45deg);
    }

The output will be shown as follows:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzL2UxMzEwNTAxLWJkYWItNDllMy1iNGQyLTQyNzNjMjFjMTE0Yg==.png)

It's rotated, but it's rotated around the center of the element. Let's add a line to what we just wrote, so it rotates around the start of the text:

Copy

    #bottom-axistext {
        transform:rotate(45deg);
        text-anchor: start; /* add this line */
    }

The output will be shown as follows:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzL2Y1ODNmZjBlLTBiMWItNDczZS05MTUxLTYyNGEyN2I3NGRiOQ==.png)

Let's move the graph to the right, so we can see the values for the left axis. Adjust our `svg` css code so it looks as follows:

Copy

    svg {
        overflow: visible;
        margin-left: 20px; /* add this line */
    }


Summary
-------

* * *

In this chapter, we learned how to use AJAX to make an asynchronous request that will populate a bar graph. In [Chapter 6](/book/application_development/9781789342383/6), _Animating SVG Elements to Create an Interactive Pie Chart_, we'll create a pie chart that animates when you remove sections from it.


Chapter 6. Animating SVG Elements to Create an Interactive Pie Chart
--------------------------------------------------------------------

In this chapter, we'll be use animation to make our graphs move. This can give your visualizations a more polished and professional feel.

In this section, we will cover the following topics:

*   Creating an ordinal scale
*   Creating a color scale
*   Adding paths for each pie segment
*   Generating an arc creating function
*   Formatting the data for the arc
*   Adjusting the position of the pie
*   Making a donut graph
*   Removing parts of the pie

The complete code for this section can be found at[https://github.com/PacktPublishing/D3.js-Quick-Start-Guide/tree/master/Chapter06](https://github.com/PacktPublishing/D3.js-Quick-Start-Guide/tree/master/Chapter06).


Setting up the application
--------------------------

* * *

As always, we'll need an `index.html` file to house our SVG code. Let's create the file and add the following code to it:

Copy


Create data/configuration variables
-----------------------------------

* * *

At the bottom of the `<body>` tag, we're referencing an `app.js` file. Let's create that file and add the following code to it:

Copy

    varWIDTH=360;
    varHEIGHT=360;
    var radius =Math.min(WIDTH, HEIGHT) /2;
    
    var dataset = [
        { label:'Bob', count:10 },
        { label:'Sally', count:20 },
        { label:'Matt', count:30 },
        { label:'Jane', count:40 }
    ];
    console.log(dataset);

To be sure that it's working and linked up properly, we've added `console.log(dataset)` to the bottom. Let's open `index.html` in Chrome and view the developer console, to make sure that everything is hooked up the way it should be:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzL2ZjMjFjYzRhLTEyMTAtNGRmNS1iZmM2LTFlYWMxNzY2MWVjNQ==.png)

Once we're sure that it's working, we can remove `console.log(dataset)`;, as follows:

Copy

    varWIDTH=360;
    varHEIGHT=360;
    var radius =Math.min(WIDTH, HEIGHT) /2;
    
    var dataset = [
        { label:'Bob', count:10 },
        { label:'Sally', count:20 },
        { label:'Matt', count:30 },
        { label:'Jane', count:40 }
    ];


Creating an ordinal scale
-------------------------

* * *

An ordinal scale maps a discrete value to some other value. A discrete value is something that can't be divided. Previously, we've used values such as numbers that can be divided up and interpolated. Interpolated just means that for any two numbers, we can find other numbers in between them. For instance, given 10 and 5, we can find values between them (6, 8.2, 7, 9.9, and so on). Now, we want to map values that can't be interpolated—the label properties in our dataset (Bob, Sally, Matt, and Jane). What values lie between Bob and Sally? What about between Bob and Matt? There are none. These are just strings, not numerical values that can be divided up and interpolated.

What we want to do is map these discrete values to other values. The following is an example of how to do this with an ordinal scale. Add the following to the bottom of `app.js`:

Copy

    var mapper =d3.scaleOrdinal();
    mapper.range([45, 63, 400]); //list each value for ordinal scales, not just min/maxmapper.domain(['Bob', 'Sally', 'Zagthor']); //list each value for ordinal scales, not just min/maxconsole.log(mapper('Bob'));
    console.log(mapper('Sally'));
    console.log(mapper('Zagthor'));

The previous code should produce the following:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzLzQ3OGU5MjEzLTI2MDUtNGQwMC05YTUyLTRhNDYwOThhN2Y3Mw==.png)

Note that when you are working with ordinal scales, you'll need to list all of the values for both the domain and range. Even if one set is numerical (in the previous case, the range), you'll still have to list each value. If we just listed the min/max for the range, omitting63, D3 would have no idea what value to map Sally to. After all, how close is Sally to Bob,as a value? How close is Sally to Zagth or, as a value? There's no way to calculate that distance, since they're all strings of text, not numbers.

One thing that's surprising is that you can't invert ordinal scales. Remove the previous three `console.log()` statements and temporarily add the following to the bottom of `app.js`:

Copy

    console.log(mapper.invert(45));

The following will be displayed:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzL2ZjMzQyZjBiLWU1M2MtNDdhMi04YmUyLWU0YWFhZmZhOWFlNQ==.png)

D3 can only go in one direction: from domain to range. You can now remove the `console.log()`statement.


Creating the color scale to map labels to colors
------------------------------------------------

* * *

Now, we want to map the label properties of our dataset to colors, instead of random numbers, like in the previous section. We can come up with our own color scheme, or we choose one of D3's sets of colors from [https://github.com/d3/d3-scale-chromatic#categorical](https://github.com/d3/d3-scale-chromatic#categorical).

If we want to, we can see that these color schemes are just arrays. Temporarily, add the following to the bottom of `app.js`:

Copy

    console.log(d3.schemeCategory10)

The following content will be displayed:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzLzU1YTVjY2VlLTE3NDctNGQ1Zi1hNWJlLTY3OTA3M2YwZGQwZA==.png)

Consequently, we can use a color scheme when setting a range. Replace the previous `console.log()` statement with the following:

Copy

    var colorScale =d3.scaleOrdinal();
    colorScale.range(d3.schemeCategory10);

We can generate an array of labels for the domain by using JavaScript's native `map` function. Add the following to the bottom of `app.js`:

Copy

    colorScale.domain(dataset.map(function(element){
        returnelement.label;
    }));

The following is our code, so far:

Copy

    varWIDTH=360;
    varHEIGHT=360;
    var radius =Math.min(WIDTH, HEIGHT) /2;
    
    var dataset = [
        { label:'Bob', count:10 },
        { label:'Sally', count:20 },
        { label:'Matt', count:30 },
        { label:'Jane', count:40 }
    ];
    
    var colorScale =d3.scaleOrdinal();
    colorScale.range(d3.schemeCategory10);
    colorScale.domain(dataset.map(function(element){
        returnelement.label;
    }));


Setting up the SVG
------------------

* * *

The next code block is pretty standard. Add the following code to the bottom of `app.js`:

Copy

    d3.select('svg')
        .attr('width', WIDTH)
        .attr('height', HEIGHT);


Adding paths for each pie segment
---------------------------------

* * *

Let's add path elements for each element in our dataset. Add the following code to the bottom of `app.js`:

Copy

    var path =d3.select('g').selectAll('path')
        .data(dataset)
        .enter()
        .append('path')
        .attr('fill', function(d) {
            returncolorScale(d.label);
        });

If we examine our elements in the developer tools, we'll see that the paths were added, and each path has a fill value, as determined by `colorScale(d.label)`, which is mapping the label of each data object to a color:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzL2ViYzk5ZGM3LTYwZWItNGIwZC1hMWEyLWVkNzFmOGIxNDEzOA==.png)


Generating an arc creating function
-----------------------------------

* * *

The paths have fill colors, but no shapes. If you'll recall, the `<path>` elements take a `d=` attribute, which determines how they're drawn. We want to set up something that will somehow map data to a `d=` string, such as the following code (you don't have to add the next code snippet; it's only there for reference):

Copy

    .attr('d', function(datum){
        //return path string here
    })

Fortunately, D3 can generate the anonymous function that we need for the second parameter of `.attr()` in the previous code snippet. Add the following to `app.js`, just before our previous code for `var path = d3.select('g').selectAll('path')...`:

Copy

    var arc =d3.arc()
        .innerRadius(0) //to make this a donut graph, adjust this value
        .outerRadius(radius);

Let's plug this function into its correct place in our previous `var path = d3.select('g').selectAll('path')...` code (it won't work yet, though):

Copy

    var path =d3.select('g').selectAll('path')
        .data(dataset)
        .enter()
        .append('path')
        .attr('d', arc) //add this
        .attr('fill', function(d) {
            returncolorScale(d.label);
        });


Formatting the data for the arc
-------------------------------

* * *

The reason that our `arc()` function won't work is the data isn't formatted properly for the function. The arc function that we generated expects the data object to have things like a start angle, an end angle, and so on. Fortunately, D3 can reformat our data so that it will work with our generated `arc()` function. To do this, we'll generate a `pie` function that will take a dataset and add the necessary attributes to it for the start angle, end angle, and so on. Add the following just before the code for `var path =d3.select('g').selectAll('path')...`:

Copy

    var pie =d3.pie()
        .value(function(d) { returnd.count; }) //use the 'count' property each value in the original array to determine how big the piece of pie should be
        .sort(null); //don't sort the values

Our `pie` variable is a function that takes an array of values as a parameter and returns an array of objects that are formatted for our `arc` function. Temporarily add the following code to the bottom of `app.js`, and take a look at the console in Chrome's Developer tools:

Copy

    console.log(pie(dataset));

The following content will be displayed:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzLzM1ZmM5MmQwLWEwMzctNGQ3Zi1iNDExLWUyMTFmZDUwYjBhZg==.png)

You can now remove the `console.log(pie(dataset))` call. We can use this `pie()` function when attaching data to our paths. Adjust the previous `var path = d3.select('g').selectAll('path')` code, as follows:

Copy

    var path =d3.select('g').selectAll('path')
        .data(pie(dataset)) //adjust this line to reformat data for arc
        .enter()
        .append('path')
        .attr('d', arc)
        .attr('fill', function(d) {
            returncolorScale(d.label);
        });

Unfortunately, now, each object from the data array that's been attached to our path elements doesn't have a `.label` property, so our code for `.attr('fill', function(d) {})`is broken. Fortunately, our data does have a `.data` attribute that mirrors what the data looked like before we passed it to the `pie()` function. Let's adjust our `var path = d3.select('g').selectAll('path')` code to use that code, instead, as follows:

Copy

    var path =d3.select('g').selectAll('path')
        .data(pie(dataset))
        .enter()
        .append('path')
        .attr('d', arc)
        .attr('fill', function(d) {
            returncolorScale(d.data.label); //use .data property to access 
            original data
        });

So far, our code is as follows:

Copy

    varWIDTH=360;
    varHEIGHT=360;
    var radius =Math.min(WIDTH, HEIGHT) /2;
    
    var dataset = [
        { label:'Bob', count:10 },
        { label:'Sally', count:20 },
        { label:'Matt', count:30 },
        { label:'Jane', count:40 }
    ];
    
    var mapper =d3.scaleOrdinal();
    var colorScale =d3.scaleOrdinal();
    colorScale.range(d3.schemeCategory10);
    colorScale.domain(dataset.map(function(element){
        returnelement.label;
    }));
    
    d3.select('svg')
        .attr('width', WIDTH)
        .attr('height', HEIGHT);
    
    var arc =d3.arc()
        .innerRadius(0)
        .outerRadius(radius);
    
    var pie =d3.pie()
        .value(function(d) { returnd.count; })
        .sort(null);
    
    var path =d3.select('g').selectAll('path')
        .data(pie(dataset))
        .enter()
        .append('path')
        .attr('d', arc)
        .attr('fill', function(d) {
            returncolorScale(d.data.label);
        });

The preceding code produces the following result:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzL2M3ZDZlZWQ5LTlhYzQtNGQ1Ny04YjZhLThlYjI2NmEyNjVhOQ==.png)


Adjusting the position of the pie
---------------------------------

* * *

Currently, we can only see the lower-right quarter of the pie graph. This is because the pie starts at (`0,0`), but we can move the `group` element containing the pie by adjusting our `d3.select('svg')` code, as follows:

Copy

    d3.select('svg')
        .attr('width', WIDTH)
        .attr('height', HEIGHT);
    var container = d3.select('g') //add this line and the next:
        .attr('transform', 'translate(' + (WIDTH / 2) + ',' + (HEIGHT / 2) + ')'); //add this line

The pie graph now looks as follows:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzL2M1MTI4NmNmLTQ4NTEtNDYwZS04ODI5LThkMDc3NjAxMzFjMg==.png)


Making a donut graph
--------------------

* * *

If you want the pie to have a hole in the center, just adjust the inner radius of the `arc()` function, as follows:

Copy

    var arc =d3.arc()
        .innerRadius(100) //to make this a donut graph, adjust this value
        .outerRadius(radius);

The graph will now look as follows:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzLzRhNDM1YTMzLWI5NzUtNDU4MC1hZmIyLWE3N2ViNzMzMWMyNQ==.png)


Removing parts of the pie
-------------------------

* * *

We want to make it possible to click on a section of the pie to remove it. First, let's add IDs to our data, to make the removal easier. Adjust the `var dataset` code at the top of `app.js`:

Copy

    var dataset = [
        { id:1, label:'Bob', count:10 }, //add id property
        { id:2, label:'Sally', count:20 }, //add id property
        { id:3, label:'Matt', count:30 }, //add id property
        { id:4, label:'Jane', count:40 } //add id property
    ];

Now, let's use those IDs when we map data to paths. Adjust the `.data()` portion of our `var path =d3.select('g').selectAll('path')`code at the bottom of `app.js`, as follows:

Copy

    var path =d3.select('g').selectAll('path')
        .data(pie(dataset), function(datum){ //attach datum.data.id to each elementreturndatum.data.id
        })

Let's save a record of the current data for each element by adding a `_current` property to each element (we'll use this later). Add `.each(function(d) { this._current = d; });`to the end of our `var path =d3.select('g')`code, at the bottom of `app.js`:

Copy

    var path =d3.select('g').selectAll('path')
        .data(pie(dataset), function(datum){
            returndatum.data.id
        })
        .enter()
        .append('path')
        .attr('d', arc)
        .attr('fill', function(d) {
            returncolorScale(d.data.label);
        })//watch out! remove the semicolon here
        .each(function(d) { this._current= d; }); //add this

Create the click handler by adding the following code to the bottom of `app.js`:

Copy

    path.on('click', function(clickedDatum, clickedIndex){
    });

Remove the selected data from the dataset array, using JavaScript's native `filter` function. Adjust the code that we just added, as follows:

Copy

    path.on('click', function(clickedDatum, clickedIndex){
        dataset =dataset.filter(function(currentDatum, currentIndex){ //newreturnclickedDatum.data.id!==currentDatum.id//new
        }); //new
    });

Remove the `path` elements from the SVG by adding the following to our click handler function:

Copy

    path.on('click', function(clickedDatum, clickedIndex){
        dataset =dataset.filter(function(currentDatum, currentIndex){
            returnclickedDatum.data.id!==currentDatum.id
        });
        path //new
            .data(pie(dataset), function(datum){ //newreturndatum.data.id//new
            }) //new
            .exit().remove(); //new
    });

Now, if we click on the orange segment, we should get the following result:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzLzlhZjI5YjQ0LTJmMWEtNDA1Yy1iOTNmLTNmMTdjNTJlNDA4ZA==.png)

Let's close the donut and add a transition. Add the following to the bottom of our click handler. Check out the comments in the following code to see what each line does:

Copy

    path.on('click', function(clickedDatum, clickedIndex){
        dataset =dataset.filter(function(currentDatum, currentIndex){
            returnclickedDatum.data.id!==currentDatum.id
        });
        path
            .data(pie(dataset), function(datum){
                returndatum.data.id
            })
            .exit().remove();
    
        path.transition() //create the transition
            .duration(750) //add how long the transition takes
            .attrTween('d', function(d) { //tween the d attributevar interpolate =d3.interpolate(this._current, d); 
                //interpolate 
                from what the d attribute was and what it is nowthis._current=interpolate(0); //save new value of datareturnfunction(t) { //re-run the arc function:returnarc(interpolate(t));
                };
            });
    });

Now, when we click on the orange segment, the donut closes smoothly, as follows:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzL2M3ZTgxMGRmLTgwMzMtNGIyZS04ODE3LWRmZjhiMjQwNjQyNA==.png)


Summary
-------

* * *

In this chapter, we created a pie chart that animates when you remove sections from it. You learned how to generate paths from data, so that you can get different parts of the pie without having to specify the drawing commands directly in the path elements. You also learned how to use animation to make visualizations look more professional. Finally, you learned how to remove sections of the pie and have the other path elements redraw themselves, so that the result will be a full pie.

In the next chapter, we will use D3 to create a graph that visualizes the relationships between various nodes of data.


Chapter 7. Using Physics to Create a Force-Directed Graph
---------------------------------------------------------

This chapter will cover how to make a force-directed graph that will visualize the relationships between various nodes.

In this lesson, you will learn about the following topics:

*   Creating a physics-based force that will center nodes
*   Creating a physics-based force that make the nodes repel each other
*   Creating a physics-based force that will link the nodes to show their relationships

The complete code for this section can be found at[https://github.com/PacktPublishing/D3.js-Quick-Start-Guide/tree/master/Chapter07](https://github.com/PacktPublishing/D3.js-Quick-Start-Guide/tree/master/Chapter07).


What is a force-directed graph?
-------------------------------

* * *

A**force**\-**directed****graph** is a graph that is affected by various forces (such as gravity and repulsion). It can be extremely helpful when creating graphs of relationships.


How to set up a graph of relationships
--------------------------------------

* * *

The following sections will provide an overview of what we're going to build. The overview will cover the display side and the physics side of the implementation.

### Display

The display aspect controls what we see; the display will include the following:

*   A list of nodes representing people, displayed as circles
*   A list of links representing connections between people, displayed as lines

### Physics

The physics of the simulation control how the elements interact, as follows:

*   A centering force at the center of the SVG will draw all of the nodes toward it
*   A repulsive force on each node will prevent the nodes from getting too close to each other
*   Link forces will connect each of the nodes, so that they don't repel each other too much


Setting up the HTML
-------------------

* * *

Our file will be a pretty standard `index.html` file, but we'll need two `<g>` elements, as follows:

*   One to contain the nodes (**people**: circles)
*   One to contain the links (**relationship**: lines)

Here's what our code should look like:

Copy


Setting up styling for nodes and links
--------------------------------------

* * *

Create an `app.css` file for our circles (nodes/people) and lines (links/relationships), as follows:

Copy

    circle {
        fill: red;
        r: 5;
    }
    
    line {
        stroke: grey;
        stroke-width: 1;
    }

Don't forget to create a link to it in your `index.html` file, as follows:

Copy


Setting up the SVG
------------------

* * *

At the top of our`app.js` file, add the following:

Copy

    varWIDTH=300;
    varHEIGHT=200;
    
    d3.select("svg")
        .attr("width", WIDTH)
        .attr("height", HEIGHT);

If we open `index.html` in Chrome and look at **`Elements`** in the Developer tools, we should see the following:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzLzFkZDA1NWMwLTRlNWQtNGY0ZS1hZjAzLTk3MDIzODM1MDY5ZA==.png)


Adding data for people
----------------------

* * *

Let's create an array of people at the bottom of `app.js`, as follows:

Copy

    var nodesData =  [
        {"name": "Charlie"},
        {"name": "Mac"},
        {"name": "Dennis"},
        {"name": "Dee"},
        {"name": "Frank"},
        {"name": "Cricket"}
    ];


Adding data for relationships
-----------------------------

* * *

Now, let's create the relationships by adding the following array to the bottom of `app.js`. Note that the attributes must be `source` and `target`, in order for D3 to do its magic:

Copy

    var linksData = [
        {"source": "Charlie", "target": "Mac"},
        {"source": "Dennis", "target": "Mac"},
        {"source": "Dennis", "target": "Dee"},
        {"source": "Dee", "target": "Mac"},
        {"source": "Dee", "target": "Frank"},
        {"source": "Cricket", "target": "Dee"}
    ];


Add circles to the SVG
----------------------

* * *

Add the following to the bottom of `app.js`:

Copy

    var nodes =d3.select("#nodes")
        .selectAll("circle")
        .data(nodesData)
        .enter()
        .append("circle");

This will create a circle for each element in our `nodesData` array. Our Developer  tools should look as follows:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzLzg0OTBlNjZmLTQyMzItNGQ1MS1hOTIzLTFiNDMyNGFhOGNlOQ==.png)


Adding lines to the SVG
-----------------------

* * *

Add the following to the bottom of`app.js`:

Copy

    var links =d3.select("#links")
        .selectAll("line")
        .data(linksData)
        .enter()
        .append("line");

This will create a line for each element in our `linksData` array. Our Developer tools should look as follows:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzLzRmOGI0OWIxLTcyMmUtNDE2Ny1iYmNjLWYxMzdkNGVlOWQ0MQ==.png)


Creating a simulation
---------------------

* * *

Now, we'll generate a simulation by adding the following to the bottom of`app.js`:

Copy

    d3.forceSimulation()

Note that this simply creates a simulation; it doesn't specify how the simulation should run. Let's tell it which data to act on by modifying the previous line of code, as follows:

Copy

    d3.forceSimulation()
        .nodes(nodesData) // add this line


Specifying how the simulation affects visual elements
-----------------------------------------------------

* * *

At this point, our visualization still looks the same, as indicated by the following screenshot:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzLzRmOGI0OWIxLTcyMmUtNDE2Ny1iYmNjLWYxMzdkNGVlOWQ0MQ==.png)

Let's make our simulation affect the circles/lines that we created, as follows:

*   The simulation runs **ticks**, which run very quickly.  Think of this a series of steps that happen very quickly, like the ticking of a stopwatch, but faster.
*   Each time a new tick occurs, you can update the visual elements. This allows our simulation to animate.
*   D3 will calculate and tack positional data onto our regular data, so that we can make use of it.

Add the following to the bottom of `app.js`:

Copy

    d3.forceSimulation()
        .nodes(nodesData)
        .on("tick", function(){
            nodes.attr("cx", function(datum) {returndatum.x;})
                .attr("cy", function(datum) {returndatum.y;});
    
            links.attr("x1", function(datum) {returndatum.source.x;})
                .attr("y1", function(datum) {returndatum.source.y;})
                .attr("x2", function(datum) {returndatum.target.x;})
                .attr("y2", function(datum) {returndatum.target.y;});
        });

Now, our circles distance themselves from each other a little bit, but this is just a side effect of not having any forces attached to them. We'll add forces next:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzLzU5NTFhZTBhLTRlOGMtNDU3Ni1hNmNmLTFiZjI3ZWI0MTVmMA==.png)


Creating forces
---------------

* * *

Let's create a centering force at the center of screen, which will pull all of the elements toward it. Adjust the code that we added in the previous step, so that it looks as follows. Not that we only add `.force("center_force", d3.forceCenter(WIDTH / 2, HEIGHT / 2)) `to the previous code:

Copy

    d3.forceSimulation()
        .nodes(nodesData)
        // add the line below this comment
        .force("center_force", d3.forceCenter(WIDTH/2, HEIGHT/2))             .on("tick", function(){
            nodes.attr("cx", function(datum) {returndatum.x;})
                .attr("cy", function(datum) {returndatum.y;});
    
            links.attr("x1", function(datum) {returndatum.source.x;})
                .attr("y1", function(datum) {returndatum.source.y;})
                .attr("x2", function(datum) {returndatum.target.x;})
                .attr("y2", function(datum) {returndatum.target.y;});
        });

Now our circles are pulled towards the center of the SVG element:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzL2NmN2ZiZjE4LTBjZGMtNDUzZS05Y2MzLTg3MTNlMThlZjk0MA==.png)

Create a force on each of the nodes, so that they repel each other. Just like in the last step, we will only add `.force("charge_force", d3.forceManyBody())` to the previous code:

Copy

    d3.forceSimulation()
        .nodes(nodesData)
        .force("center_force", d3.forceCenter(WIDTH/2, HEIGHT/2))
        // add the line below this comment
        .force("charge_force", d3.forceManyBody())
        .on("tick", function(){
            nodes.attr("cx", function(datum) {returndatum.x;})
                .attr("cy", function(datum) {returndatum.y;});
    
            links.attr("x1", function(datum) {returndatum.source.x;})
                .attr("y1", function(datum) {returndatum.source.y;})
                .attr("x2", function(datum) {returndatum.target.x;})
                .attr("y2", function(datum) {returndatum.target.y;});
        });

You'll notice that the `cx`/`cy` values for the circles initially change rapidly, before finally stopping. This is because D3 is running a simulation. Note that `center_force` is trying to reach a state of equilibrium with `charge_force`. You'll even notice that when you first load the page, the circles move outward from the center. This is due to the same reason:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzLzA1NGMxMDNmLWU1YTYtNDAzMy04MGIzLTFkM2IyNmI5MWIyMg==.png)

Finally, we'll create the links between the nodes, so that they don't repel each other too much. Just like in the last step, we will add the following code to the previous code:

Copy

    .force("links", d3.forceLink(linksData).id(function(datum){
        returndatum.name
    }).distance(160))

Our last chunk of code should now look as follows:

Copy

    d3.forceSimulation()
        .nodes(nodesData)
        .force("center_force", d3.forceCenter(WIDTH/2, HEIGHT/2))
        .force("charge_force", d3.forceManyBody())
        //add the three lines below this comment
        .force("links", d3.forceLink(linksData).id(function(datum){
    returndatum.name
        }).distance(160))
        .on("tick", function(){
            nodes.attr("cx", function(datum) {returndatum.x; })
                .attr("cy", function(datum) {returndatum.y; });
    
            links.attr("x1", function(datum) {returndatum.source.x;})
                .attr("y1", function(datum) {returndatum.source.y;})
                .attr("x2", function(datum) {returndatum.target.x;})
                .attr("y2", function(datum) {returndatum.target.y;});
        });

*   The d3.forceLink function takes the array of links. It then uses the source and target attributes of each link data object to connect the nodes via their `.name` properties (as specified in the return value of the function we just wrote).
*   You can tack on `.distance()` to specify how long the lines are visually between each circle.

Finally, our graph looks as follows:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzLzZmODhhNjA5LTQzNWUtNDFmOS04OTFhLTA2OGQxYTBhMTVkZg==.png)


Summary
-------

* * *

In this chapter, we used D3 to create a graph that visualizes relationships between various nodes of data. This can be very useful in scenarios such as graphing a friend network, showing parent/child company relationships, or displaying a company's staff hierarchy.

In [Chapter 8](/book/application_development/9781789342383/8), _Mapping_, we'll cover how to create a map from GeoJSON data.


Chapter 8. Mapping
------------------

D3 is a great tool for generating maps. To do so, we use specially formatted JSON data to generate `<path>` SVG elements. This specially formatted JSON data is called **GeoJSON**, and in this chapter, we'll use it to create a map of the world.

In this chapter, we will cover the following topics: 

*   Creating a map
*   Defining GeoJSON
*   Using a projection
*   Generating a `<path>` using a projection and GeoJSON data

The complete code for this chapter can be found at https: [https://github.com/PacktPublishing/D3.js-Quick-Start-Guide/tree/master/Chapter08](https://github.com/PacktPublishing/D3.js-Quick-Start-Guide/tree/master/Chapter08).


Defining GeoJSON
----------------

* * *

GeoJSON is just JSON data that has specific properties that are assigned specific data types. The following is an example of GeoJSON:

Copy

    {
        "type":"Feature",
        "geometry": {
            "type":"Point",
            "coordinates": [125.6, 10.1]
        },
        "properties": {
            "name":"Dinagat Islands"
        }
    }

In this example, we have one `Feature`, the `geometry` of which is a `Point` with the coordinates `[125.6, 10.1]`. Its name is `Dinagat Islands`. Each `Feature` will follow this general structure. An example, with the type as `STRING`, is as follows:

Copy

    {
        "type":STRING,
        "geometry": {
            "type":STRING,
            "coordinates":ARRAY
        },
        "properties":OBJECT
    }

We can also have a `FeatureCollection`, which includes many features grouped together in a `features` array. In the following code snippet, you can see an example of `FeatureCollection` with different `geometry`:

Copy

    {
        "type":"FeatureCollection",
        "features": [
            {
                "type":"Feature",
                "geometry": {
                    "type":"Point",
                    "coordinates": [102.0, 0.5]
                },
                "properties": {
                    "prop0":"value0"
                }
            },
            {
                "type":"Feature",
                "geometry": {
                    "type":"LineString",
                    "coordinates": [
                        [102.0, 0.0], [103.0, 1.0], [104.0,   
    0.0], [105.0, 1.0]
                    ]
                },
                "properties": {
                    "prop0":"value0",
                    "prop1":0.0
                }
            },
            {
                "type":"Feature",
                "geometry": {
                    "type":"Polygon",
                    "coordinates": [
                        [
                           [100.0, 0.0], [101.0, 0.0], 
                           [101.0, 1.0], [100.0, 1.0], 
                            [100.0, 0.0]
                        ]
                    ]
                },
                "properties": {
                    "prop0":"value0",
                    "prop1": { "this":"that" }
                }
            }
        ]
    }

Here's the general form:

Copy

    {
        "type":"FeatureCollection",
        "features":ARRAY
    }

The `features` property is an array of feature objects that were defined previously.


Setting up the HTML
-------------------

* * *

Let's set up a basic D3 page, using the following code:

Copy

Copy

The only thing different than the setup we've used in previous chapters is the following line:

Copy

The preceding line just loads an external JavaScript file, which sets our GeoJSON data to a variable.  The beginning of the code looks as follows:

Copy

    var map_json = {
        type:"FeatureCollection",
        features: [
            {
                type:"Feature",
                id:"AFG",
                properties: {
                    name:"Afghanistan"
                },
                geometry: {
                    type:"Polygon",
                    coordinates: [
                        //lots of coordinates
                    ]
                }
            }
            // lots of other countries
        ]
    }

Note that the `map_json` variable is just a JavaScript object that adheres to the GeoJSON structure (it adds an `idproperty`, which is optional). This is very important. If the object didn't adhere to the GeoJSON structure, D3 would not work as it should.

In production, you would probably make an AJAX call to get this data or, at the very least, create your own GeoJSON file, similar to the one being hosted on [https://rawgit.com/](https://rawgit.com/). The preceding setup was created to make learning easier, by decreasing the complexity associated with AJAX.


Using a projection
------------------

* * *

Now, let's start on our `app.js` file, as follows:

Copy

    var width =960;
    var height =490;
    
    d3.select('svg')
        .attr('width', width)
        .attr('height', height);

At the bottom of `app.js`, let's add the following code:

Copy

    var worldProjection =d3.geoEquirectangular();

This generates a projection, which governs how we're going to display a round world on a flat screen. There are lots of different types of projections that we can use, which can be seen at [https://github.com/d3/d3-geo/blob/master/README.md#azimuthal-projections](https://github.com/d3/d3-geo/blob/master/README.md#azimuthal-projections).

The preceding line tells D3 to create an `equirectangular` projection ([https://github.com/d3/d3-geo/blob/master/README.md#geoEquirectangular](https://github.com/d3/d3-geo/blob/master/README.md#geoEquirectangular)).


Generating a path using a projection and GeoJSON data
-----------------------------------------------------

* * *

Now that we have our projection, we're going to generate `<path>` elements for each data element in the `map_json.features` array. Then, we will set the fill of each element to `#099`. Add the following to the end of `app.js`:

Copy

    d3.select('svg').selectAll('path')
        .data(map_json.features)
        .enter()
        .append('path')
        .attr('fill', '#099');

The following screenshot shows what it should look if we open `index.html` in Chrome and view the **`Elements`** tab in the Developer tools:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzLzA4YmEwZWY5LTgxNjYtNDM4Yi1hNGQyLTI4YTYwMzEyYWQ0MQ==.png)

We created the path elements, but they each need a `d` attribute, which will determine how they will be drawn (that is, their shapes).

We want something like the following:

Copy

    d3.selectAll('path').attr('d', function(datum, index){
        //use datum to generate the value for the 'd' attributes
    });

Writing the kind of code described in the preceding comment would be very difficult. Luckily, D3 can generate that entire function for us. All we need to do is specify the projection that we created earlier. At the bottom of `app.js`, add the following code:

Copy

    var dAttributeFunction =d3.geoPath()
        .projection(worldProjection);
    
    d3.selectAll('path').attr('d', dAttributeFunction);

`geoPath()` generates the function that we'll use for the `d` attribute, and the projection (`worldProjection`) tells it to use the `worldProjection` variable created earlier, so that the path elements appear as an equirectangular projection, as follows:

![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzLzAyYmE4NjkzLTQxZjItNDE2NC1iZjRmLTgyYjU0MWU4MWEzYw==.png)


Summary
-------

* * *

In this chapter, we discussed GeoJSON, what it's used for, and why it differs from more general JSON data.  We've also covered how to use D3 to create a projection and render GeoJSON data as a map.  Using this information, we can create all sorts of interesting maps of countries, cities, towns, or any area that we have GeoJSON data for.  We can use different projections to view this data in interesting ways

Congratulations! You've made it to the end of the book. Now, go and create amazing visualizations.


Appendix 1. Other Books You May Enjoy
-------------------------------------

If you enjoyed this book, you may be interested in these other books by Packt:

[![](./images/aHR0cHM6Ly9zdGF0aWMucGFja3QtY2RuLmNvbS9wcm9kdWN0cy85NzgxNzg5MzQyMzgzL2dyYXBoaWNzLzkzN2NkYmE0LTgxMjctNDE3NS1iZTA3LTU5MjNhNDYxOTkzMg==.png)](https://www.packtpub.com/web-development/learning-d3js-5-mapping-second-edition)

**Learning D3.js 5 Mapping – Second Edition** Thomas Newton, Oscar Villarreal, Lars Verspohl

ISBN: 978-1-78728-017-5

*   Work with SVG geometric shapes
*   Learn to manage map data and plot it with D3.js
*   Add interactivity and points of interest to your maps
*   Compress and manipulate geoJSON files with the use of topoJSON
*   Learn how to write testable D3.js visualizations
*   Build a globe with D3.js and Canvas and add interactivity to it
*   Create a hexbin map with D3.js


Leave a review - let other readers know what you think
------------------------------------------------------

* * *

Please share your thoughts on this book with others by leaving a review on the site that you bought it from. If you purchased the book from Amazon, please leave us an honest review on this book's Amazon page. This is vital so that other potential readers can see and use your unbiased opinion to make purchasing decisions, we can understand what our customers think about our products, and our authors can see your feedback on the title that they have worked with Packt to create. It will only take a few minutes of your time, but is valuable to other potential customers, our authors, and Packt. Thank you!


Index
=====

A
-

*   AJAX data
    *   used, for creating SVG elements / [Using AJAX data to create SVG elements](/book/application_development/9781789342383/5/ch05lvl1sec49/using-ajax-data-to-create-svg-elements "Using AJAX data to create SVG elements")
*   AJAX request
    *   making / [Making an AJAX request](/book/application_development/9781789342383/5/ch05lvl1sec48/making-an-ajax-request "Making an AJAX request")
    *   basic code, writing / [Writing the basic code](/book/application_development/9781789342383/5/ch05lvl1sec48/making-an-ajax-request "Writing the basic code")
    *   file access, handling / [Handling file access](/book/application_development/9781789342383/5/ch05lvl1sec48/making-an-ajax-request "Handling file access")
*   arc
    *   about / [Arcs](/book/application_development/9781789342383/2/ch02lvl1sec20/important-svg-elements "Arcs")
    *   data, formatting / [Formatting the data for the arc](/book/application_development/9781789342383/6/ch06lvl1sec63/formatting-the-data-for-the-arc "Formatting the data for the arc")
*   arc creating function
    *   generating / [Generating an arc creating function](/book/application_development/9781789342383/6/ch06lvl1sec62/generating-an-arc-creating-function "Generating an arc creating function")
*   Atom
    *   reference / [Setting up](/book/application_development/9781789342383/1/ch01lvl1sec14/setting-up "Setting up")
*   axes
    *   creating / [Creating axes](/book/application_development/9781789342383/3/ch03lvl1sec33/creating-axes "Creating axes")
    *   updating, when panning / [Updating axes when zooming and panning](/book/application_development/9781789342383/4/ch04lvl1sec41/updating-axes-when-zooming-and-panning "Updating axes when zooming and panning")
    *   updating, when zooming / [Updating axes when zooming and panning](/book/application_development/9781789342383/4/ch04lvl1sec41/updating-axes-when-zooming-and-panning "Updating axes when zooming and panning")
    *   adding / [Adding axes](/book/application_development/9781789342383/5/ch05lvl1sec54/adding-axes "Adding axes")

B
-

*   bar color
    *   modifying, based on data / [Changing the color of the bar based on data](/book/application_development/9781789342383/5/ch05lvl1sec53/changing-the-color-of-the-bar-based-on-data "Changing the color of the bar based on data")
*   bar graph
    *   creating, data file used / [Creating a bar graph using a data file](/book/application_development/9781789342383/1/ch01lvl1sec13/a-preview-of-each-build "Creating a bar graph using a data file")
    *   setting / [Setting up our application](/book/application_development/9781789342383/5/ch05lvl1sec46/setting-up-our-application "Setting up our application")
*   bars
    *   width, adjusting / [Adjusting the height and the width of the bars](/book/application_development/9781789342383/5/ch05lvl1sec50/adjusting-the-height-and-the-width-of-the-bars "Adjusting the height and the width of the bars")
    *   height, adjusting / [Adjusting the height and the width of the bars](/book/application_development/9781789342383/5/ch05lvl1sec50/adjusting-the-height-and-the-width-of-the-bars "Adjusting the height and the width of the bars")
    *   horizontal and the vertical placement, adjusting / [Adjusting the horizontal and the vertical placement of the bars](/book/application_development/9781789342383/5/ch05lvl1sec51/adjusting-the-horizontal-and-the-vertical-placement-of-the-bars "Adjusting the horizontal and the vertical placement of the bars")
    *   horizontal and vertical placement, adjusting / [Adjusting the horizontal and the vertical placement of the bars](/book/application_development/9781789342383/5/ch05lvl1sec51/adjusting-the-horizontal-and-the-vertical-placement-of-the-bars "Adjusting the horizontal and the vertical placement of the bars")
*   bar width
    *   creating / [Making the width of the bars dynamic](/book/application_development/9781789342383/5/ch05lvl1sec52/making-the-width-of-the-bars-dynamic "Making the width of the bars dynamic")
*   base tag / [Base tag](/book/application_development/9781789342383/2/ch02lvl1sec16/base-tag "Base tag")
*   basic elements / [Basic elements](/book/application_development/9781789342383/2/ch02lvl1sec17/basic-elements "Basic elements")
*   basic scatter plot
    *   making, interactive / [Making a basic scatter plot interactive](/book/application_development/9781789342383/1/ch01lvl1sec13/a-preview-of-each-build "Making a basic scatter plot interactive")
*   Bezier curves
    *   about / [Bezier curves](/book/application_development/9781789342383/2/ch02lvl1sec20/important-svg-elements "Bezier curves")
    *   cubic / [Cubic Bezier curves](/book/application_development/9781789342383/2/ch02lvl1sec20/important-svg-elements "Cubic Bezier curves")
    *   reference / [Cubic Bezier curves](/book/application_development/9781789342383/2/ch02lvl1sec20/important-svg-elements "Cubic Bezier curves")
    *   smooth / [Smooth cubic Bezier curves](/book/application_development/9781789342383/2/ch02lvl1sec20/important-svg-elements "Smooth cubic Bezier curves")
    *   quadratic / [Quadratic Bezier curve](/book/application_development/9781789342383/2/ch02lvl1sec20/important-svg-elements "Quadratic Bezier curve")
    *   smooth quadratic / [Smooth quadratic Bezier curve](/book/application_development/9781789342383/2/ch02lvl1sec20/important-svg-elements "Smooth quadratic Bezier curve")

C
-

*   Chrome
    *   download link / [Setting up](/book/application_development/9781789342383/1/ch01lvl1sec14/setting-up "Setting up")
*   click handler
    *   creating / [Creating a click handler](/book/application_development/9781789342383/4/ch04lvl1sec36/creating-a-click-handler "Creating a click handler")
    *   adding / [Removing data](/book/application_development/9781789342383/4/ch04lvl1sec37/removing-data "Removing data")
*   click points
    *   updating, after transform / [Updating click points after a transform](/book/application_development/9781789342383/4/ch04lvl1sec42/updating-click-points-after-a-transform "Updating click points after a transform")
*   color scale
    *   creating, for mapping labels to colors / [Creating the color scale to map labels to colors](/book/application_development/9781789342383/6/ch06lvl1sec59/creating-the-color-scale-to-map-labels-to-colors "Creating the color scale to map labels to colors")
*   config vars
    *   setting up / [Create data/configuration variables](/book/application_development/9781789342383/6/ch06lvl1sec57/create-data-configuration-variables "Create data/configuration variables")

D
-

*   D3 library
    *   link, adding / [Adding a link to the D3 library](/book/application_development/9781789342383/3/ch03lvl1sec22/adding-a-link-to-the-d3-library "Adding a link to the D3 library")
*   d3-notes
    *   reference / [A preview of each build](/book/application_development/9781789342383/1/ch01lvl1sec13/a-preview-of-each-build "A preview of each build")
*   D3.js library
    *   about / [What is SVG?](/book/application_development/9781789342383/1/ch01lvl1sec10/what-is-svg "What is SVG?")
    *   features / [What makes D3 so special?](/book/application_development/9781789342383/1/ch01lvl1sec11/what-makes-d3-so-special "What makes D3 so special?")
*   data
    *   attaching, to visual elements / [Attaching data to visual elements](/book/application_development/9781789342383/3/ch03lvl1sec27/attaching-data-to-visual-elements "Attaching data to visual elements")
    *   displaying, in table / [Displaying data in a table](/book/application_development/9781789342383/3/ch03lvl1sec34/displaying-data-in-a-table "Displaying data in a table")
    *   removing / [Removing data](/book/application_development/9781789342383/4/ch04lvl1sec37/removing-data "Removing data")
    *   updating, after drag / [Updating data after a drag](/book/application_development/9781789342383/4/ch04lvl1sec39/updating-data-after-a-drag "Updating data after a drag")
    *   formatting, for arc / [Formatting the data for the arc](/book/application_development/9781789342383/6/ch06lvl1sec63/formatting-the-data-for-the-arc "Formatting the data for the arc")
    *   for people, adding / [Adding data for people](/book/application_development/9781789342383/7/ch07lvl1sec73/adding-data-for-people "Adding data for people")
    *   for relationships, adding / [Adding data for relationships](/book/application_development/9781789342383/7/ch07lvl1sec74/adding-data-for-relationships "Adding data for relationships")
*   data, attached to visual elements
    *   using / [Use data attached to a visual element to affect its appearance](/book/application_development/9781789342383/3/ch03lvl1sec28/use-data-attached-to-a-visual-element-to-affect-its-appearance "Use data attached to a visual element to affect its appearance")
*   data file
    *   used, for creating bar graph / [Creating a bar graph using a data file](/book/application_development/9781789342383/1/ch01lvl1sec13/a-preview-of-each-build "Creating a bar graph using a data file")
*   date string
    *   formatting / [Parsing and formatting times](/book/application_development/9781789342383/3/ch03lvl1sec30/parsing-and-formatting-times "Parsing and formatting times")
    *   parsing / [Parsing and formatting times](/book/application_development/9781789342383/3/ch03lvl1sec30/parsing-and-formatting-times "Parsing and formatting times")
*   donut graph
    *   creating / [Making a donut graph](/book/application_development/9781789342383/6/ch06lvl1sec65/making-a-donut-graph "Making a donut graph")
*   dynamic domains
    *   setting / [Setting dynamic domains](/book/application_development/9781789342383/3/ch03lvl1sec31/setting-dynamic-domains "Setting dynamic domains")

E
-

*   element
    *   positioning / [Positioning an element](/book/application_development/9781789342383/2/ch02lvl1sec18/positioning-an-element "Positioning an element")
    *   styling / [Styling an element](/book/application_development/9781789342383/2/ch02lvl1sec19/styling-an-element "Styling an element")
    *   dragging / [Dragging an element](/book/application_development/9781789342383/4/ch04lvl1sec38/dragging-an-element "Dragging an element")
*   elements, beyond axis
    *   hiding / [Hiding elements beyond an axis](/book/application_development/9781789342383/4/ch04lvl1sec44/hiding-elements-beyond-an-axis "Hiding elements beyond an axis")
*   entire screen redraw
    *   avoiding, during rendering / [Avoiding redrawing the entire screen during rendering](/book/application_development/9781789342383/4/ch04lvl1sec43/avoiding-redrawing-the-entire-screen-during-rendering "Avoiding redrawing the entire screen during rendering")
*   equirectangular projection
    *   reference / [Using a projection](/book/application_development/9781789342383/8/ch08lvl1sec83/using-a-projection "Using a projection")
*   external file
    *   creating, for data storage / [Creating an external file to hold our data](/book/application_development/9781789342383/5/ch05lvl1sec47/creating-an-external-file-to-hold-our-data "Creating an external file to hold our data")

F
-

*   fake data
    *   creating, for app / [Creating some fake data for our app](/book/application_development/9781789342383/3/ch03lvl1sec24/creating-some-fake-data-for-our-app "Creating some fake data for our app")
*   force-directed graph
    *   creating, physics used / [Using physics to create a force-directed graph](/book/application_development/9781789342383/1/ch01lvl1sec13/a-preview-of-each-build "Using physics to create a force-directed graph")
    *   about / [What is a force-directed graph?](/book/application_development/9781789342383/7/ch07lvl1sec68/what-is-a-force-directed-graph "What is a force-directed graph?")
*   forces
    *   creating / [Creating forces](/book/application_development/9781789342383/7/ch07lvl1sec79/creating-forces "Creating forces")

G
-

*   GeoJSON
    *   used, for creating world map / [Mapping](/book/application_development/9781789342383/1/ch01lvl1sec13/a-preview-of-each-build "Mapping")
    *   defining / [Defining GeoJSON](/book/application_development/9781789342383/8/ch08lvl1sec81/defining-geojson "Defining GeoJSON")
    *   used, for generating path / [Generating a path using a projection and GeoJSON data](/book/application_development/9781789342383/8/ch08lvl1sec84/generating-a-path-using-a-projection-and-geojson-data "Generating a path using a projection and GeoJSON data")
*   graph of relationships
    *   setting up / [How to set up a graph of relationships](/book/application_development/9781789342383/7/ch07lvl1sec69/how-to-set-up-a-graph-of-relationships "How to set up a graph of relationships")
    *   display / [Display](/book/application_development/9781789342383/7/ch07lvl1sec69/how-to-set-up-a-graph-of-relationships "Display")
    *   physics / [Physics](/book/application_development/9781789342383/7/ch07lvl1sec69/how-to-set-up-a-graph-of-relationships "Physics")

H
-

*   HTML
    *   setting up / [Setting up the HTML](/book/application_development/9781789342383/7/ch07lvl1sec70/setting-up-the-html "Setting up the HTML"), [Setting up the HTML](/book/application_development/9781789342383/8/ch08lvl1sec82/setting-up-the-html "Setting up the HTML")

I
-

*   images
    *   creating, SVG used / [Using SVG to create images using code](/book/application_development/9781789342383/1/ch01lvl1sec13/a-preview-of-each-build "Using SVG to create images using code")
*   interactive pie chart
    *   creating, by animating SVG / [Animating SVG elements to create an interactive pie chart](/book/application_development/9781789342383/1/ch01lvl1sec13/a-preview-of-each-build "Animating SVG elements to create an interactive pie chart")
    *   setting up / [Setting up the application](/book/application_development/9781789342383/6/ch06lvl1sec56/setting-up-the-application "Setting up the application")
*   interactive scatter plot
    *   building / [Building an interactive scatter plot](/book/application_development/9781789342383/1/ch01lvl1sec13/a-preview-of-each-build "Building an interactive scatter plot")

L
-

*   labels, mapping to colors
    *   color scale, creating / [Creating the color scale to map labels to colors](/book/application_development/9781789342383/6/ch06lvl1sec59/creating-the-color-scale-to-map-labels-to-colors "Creating the color scale to map labels to colors")
*   linear scale
    *   creating / [Creating a linear scale](/book/application_development/9781789342383/3/ch03lvl1sec26/creating-a-linear-scale "Creating a linear scale")
*   links
    *   styling, setting up / [Setting up styling for nodes and links](/book/application_development/9781789342383/7/ch07lvl1sec71/setting-up-styling-for-nodes-and-links "Setting up styling for nodes and links")

N
-

*   node
    *   reference / [Setting up](/book/application_development/9781789342383/1/ch01lvl1sec14/setting-up "Setting up")
    *   styling, setting up / [Setting up styling for nodes and links](/book/application_development/9781789342383/7/ch07lvl1sec71/setting-up-styling-for-nodes-and-links "Setting up styling for nodes and links")

O
-

*   ordinal scale
    *   creating / [Creating an ordinal scale](/book/application_development/9781789342383/6/ch06lvl1sec58/creating-an-ordinal-scale "Creating an ordinal scale")

P
-

*   path
    *   drawing / [Drawing a path](/book/application_development/9781789342383/2/ch02lvl1sec20/important-svg-elements "Drawing a path")
    *   adding, to pie segment / [Adding paths for each pie segment](/book/application_development/9781789342383/6/ch06lvl1sec61/adding-paths-for-each-pie-segment "Adding paths for each pie segment")
*   pie
    *   parts, removing / [Removing parts of the pie](/book/application_development/9781789342383/6/ch06lvl1sec66/removing-parts-of-the-pie "Removing parts of the pie")
*   pie segment
    *   paths, adding / [Adding paths for each pie segment](/book/application_development/9781789342383/6/ch06lvl1sec61/adding-paths-for-each-pie-segment "Adding paths for each pie segment")
*   pipe
    *   position, adding / [Adjusting the position of the pie](/book/application_development/9781789342383/6/ch06lvl1sec64/adjusting-the-position-of-the-pie "Adjusting the position of the pie")
*   projection
    *   using / [Using a projection](/book/application_development/9781789342383/8/ch08lvl1sec83/using-a-projection "Using a projection")
    *   reference / [Using a projection](/book/application_development/9781789342383/8/ch08lvl1sec83/using-a-projection "Using a projection")
    *   used, for generating path / [Generating a path using a projection and GeoJSON data](/book/application_development/9781789342383/8/ch08lvl1sec84/generating-a-path-using-a-projection-and-geojson-data "Generating a path using a projection and GeoJSON data")

Q
-

*   Quadratic Bezier curves
    *   reference / [Cubic Bezier curves](/book/application_development/9781789342383/2/ch02lvl1sec20/important-svg-elements "Cubic Bezier curves")

S
-

*   Scalable Vector Graphics (SVG)
    *   about / [What is SVG?](/book/application_development/9781789342383/1/ch01lvl1sec10/what-is-svg "What is SVG?")
    *   used, for creating images using code / [Using SVG to create images using code](/book/application_development/9781789342383/1/ch01lvl1sec13/a-preview-of-each-build "Using SVG to create images using code")
    *   setting up / [Setting up the SVG](/book/application_development/9781789342383/6/ch06lvl1sec60/setting-up-the-svg "Setting up the SVG"), [Setting up the SVG](/book/application_development/9781789342383/7/ch07lvl1sec72/setting-up-the-svg "Setting up the SVG")
    *   circles, adding / [Add circles to the SVG](/book/application_development/9781789342383/7/ch07lvl1sec75/add-circles-to-the-svg "Add circles to the SVG")
    *   lines, adding / [Adding lines to the SVG](/book/application_development/9781789342383/7/ch07lvl1sec76/adding-lines-to-the-svg "Adding lines to the SVG")
*   simulation
    *   creating / [Creating a simulation](/book/application_development/9781789342383/7/ch07lvl1sec77/creating-a-simulation "Creating a simulation")
*   SVG circles
    *   styling / [Adding SVG circles and styling them](/book/application_development/9781789342383/3/ch03lvl1sec25/adding-svg-circles-and-styling-them "Adding SVG circles and styling them")
    *   adding / [Adding SVG circles and styling them](/book/application_development/9781789342383/3/ch03lvl1sec25/adding-svg-circles-and-styling-them "Adding SVG circles and styling them")
*   SVG elements
    *   animating, for creation of interactive pie chart / [Animating SVG elements to create an interactive pie chart](/book/application_development/9781789342383/1/ch01lvl1sec13/a-preview-of-each-build "Animating SVG elements to create an interactive pie chart")
    *   about / [Important SVG elements](/book/application_development/9781789342383/2/ch02lvl1sec20/important-svg-elements "Important SVG elements")
    *   circle / [Circle](/book/application_development/9781789342383/2/ch02lvl1sec20/important-svg-elements "Circle")
    *   line / [Line](/book/application_development/9781789342383/2/ch02lvl1sec20/important-svg-elements "Line")
    *   rectangle / [Rectangle](/book/application_development/9781789342383/2/ch02lvl1sec20/important-svg-elements "Rectangle")
    *   ellipse / [Ellipse](/book/application_development/9781789342383/2/ch02lvl1sec20/important-svg-elements "Ellipse")
    *   polygon / [Polygon](/book/application_development/9781789342383/2/ch02lvl1sec20/important-svg-elements "Polygon")
    *   polyline / [Polyline](/book/application_development/9781789342383/2/ch02lvl1sec20/important-svg-elements "Polyline")
    *   text / [Text](/book/application_development/9781789342383/2/ch02lvl1sec20/important-svg-elements "Text")
    *   group / [Group](/book/application_development/9781789342383/2/ch02lvl1sec20/important-svg-elements "Group")
    *   Bezier curves / [Bezier curves](/book/application_development/9781789342383/2/ch02lvl1sec20/important-svg-elements "Bezier curves")
    *   path, elements / [Drawing a path](/book/application_development/9781789342383/2/ch02lvl1sec20/important-svg-elements "Drawing a path")
    *   documentation, reference / [Documentation](/book/application_development/9781789342383/2/ch02lvl1sec20/important-svg-elements "Documentation")
    *   generating dynamically / [Dynamically generating SVG elements](/book/application_development/9781789342383/3/ch03lvl1sec32/dynamically-generating-svg-elements "Dynamically generating SVG elements")
    *   creating, AJAX data used / [Using AJAX data to create SVG elements](/book/application_development/9781789342383/5/ch05lvl1sec49/using-ajax-data-to-create-svg-elements "Using AJAX data to create SVG elements")

T
-

*   time scale
    *   creating / [Creating a time scale](/book/application_development/9781789342383/3/ch03lvl1sec29/creating-a-time-scale "Creating a time scale")

V
-

*   visual elements
    *   data, attaching / [Attaching data to visual elements](/book/application_development/9781789342383/3/ch03lvl1sec27/attaching-data-to-visual-elements "Attaching data to visual elements")
    *   simulation, affecting / [Specifying how the simulation affects visual elements](/book/application_development/9781789342383/7/ch07lvl1sec78/specifying-how-the-simulation-affects-visual-elements "Specifying how the simulation affects visual elements")

Z
-

*   zoom behavior
    *   creating / [Creating a zoom behavior that scales elements](/book/application_development/9781789342383/4/ch04lvl1sec40/creating-a-zoom-behavior-that-scales-elements "Creating a zoom behavior that scales elements")


